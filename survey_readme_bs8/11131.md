# Distributed Key-Value Database - "Krita"

This README serves as a guide for installing, using, deploying, and developing Krita - a scalable and fault- tolerant distributed key-value data store. It aims to provide a comprehensive document, catering to diverse user levels from initial adopters to seasoned contributors. Krita offers a powerful alternative within environments that deal with substantial data volume needs, demanding rapid lookup performance, and requiring robust availability. It is suitable to handle a large variety load.

## 1. Description

Krita is a system that distributes key- value store operations across multiple machines to provide improved performance and increased capacity.  It supports simple get operations for keys, as well a put to insert or update key values.  It' is based on a peer-to-peer architecture with each node responsible for storing a portion of the data. Replication is employed to ensure data consistency and fault tolerance in the event of node failures.

The architecture employs a consistent hashing scheme for even data distribution. This scheme ensures that keys are assigned to nodes in a predictable and scalable fashion.  The system incorporates a consensus algorithm (RAFT) for coordination and leader election, maintaining system consistency across all nodes in response to changes.

Krita is designed for high availability. The peer nodes automatically detect and resolve failures via a voting mechanism. This enables Krita to continue serving requests even when some machines are unavailable, thus maximizing uptime for critical processes. Furthermore, a detailed health reporting system helps administrators monitor and manage the cluster.

The system is built using Go for high concurrency and efficient resource utilization.  Its modular design makes it extensible to incorporate new features or adapt to different requirements. The system is also well-documented, which makes it easy for developers to build on. The goal is to provide a foundation for scalable and resilient data management.  

Krita aims to address the limitations of traditional single-node databases and offer a more robust solution for modern, distributed environments. It also prioritizes a clean interface.

## 2. Installation Instructions

Prerequisites include Go 1.20 or higher and Docker for optional containerized deployment.  A reasonably modern operating system is required with adequate memory to run the required Go programs, as well. Please verify that both programs have properly configured their paths before beginning this setup process, otherwise there will be a significant chance for problems when trying to start up the server processes.

To begin, clone the repository from GitHub:

```bash
git clone https://github.com/your-org/krita.git
cd krita
```

Navigate to the directory containing the necessary binaries for deployment, often in the "cmd/" directory within the repo:

```bash
cd cmd/krita-server
```

Then proceed to make an executable file with:
```bash
go build .
```

Ensure that necessary environment configurations have been setup before deployment and use.
If using Docker, the required dependencies can be handled automatically via Docker Compose which simplifies the build.

Before proceeding, make sure `KRITA_PORT` environment variable is defined; default 8080

The server requires a persistent disk.
```terraform
terraform init ..
terraform apply
```
These are required to allow storage on disks.

For running a standalone instance on macOS or Linux you should create directories.
`mkdir -p ./data ./logs`
For a container you need to specify these locations with `VOLUME` mounts

Windows user can specify these folders by setting an ENV path in the .env.docker.compose or by mounting folders.

Install any necessary third-party libraries, as identified by your build dependencies in your project, if applicable, usually done automatically using `go mod tidy`. If using an IDE ensure dependencies are correctly updated to match current code versions.
Verify correct versions and packages with:

```bash
go mod tidy
```

Ensure sufficient storage for persistent data is provisioned; insufficient space results in data corruption.

To launch an instance use.
```bash
./krita-server
```

You can then verify by accessing port using telnet

## 3. Usage Instructions

Basic get/put operations can be accomplished using a HTTP request library (like curl). First, launch at least one `krita-server` node using: `./krita-server.`  Make sure you specify any configuration settings as needed via environmental parameters like `--port=xxx` where "xxx" indicates an alternative listening port for HTTP operations.

The primary endpoints of Krita is to provide GET operations via HTTP

```bash
curl http://localhost:8080/key?value=somevalue
```

For a put command use
```bash
curl -X PUT http://localhost:8080/key -d "value=new_value"
```

For setting keys to a specific server. The following will specify port 9000,
```bash
curl -X PUT http://localhost:9000/key -d "value=new_value"
```

Advanced usage is to manage cluster. The server will automatically start up cluster configuration if none are given by way of environment configurations, however, one can use `--join_ip=[IP address]` or `--start_cluster`. These operations can then create cluster management via `./krita-admin`
The admin utility allows operations across an array of peers.
To check status:
```bash
./krita-admin cluster status
```
For managing keys and deleting:
```bash
./krita-admin key delete mykey
```

Error checking for GET and PUT are done through status codes and messages on response bodies to provide detailed context in the situation something went amiss,

Krita utilizes health-check endpoints on `/health`

You can use the command curl on all peers and confirm all respond appropriately with HTTP 200 code, to indicate a successful response.

If you have multiple server instances configured you will need to provide all server ports when using `./krita-admin`. If no parameters are configured then a single connection to that host on port is created by the cluster configuration tool

You can specify configurations on the cluster for specific nodes by running multiple server commands and joining them via their IP addresses on command-line invocation for each

For testing purpose establish a simple client that connects with Krita API. For this case one should write in any of go, Python, nodeJS or C++ depending on preferences and existing skillsets for a faster integration cycle.

## 4. Configuration

Krita is highly configurable using a variety of environment variables and CLI parameters, making adjustments straightforward based upon needs for performance. Every peer will use its default port to communicate. To modify it you need to use environment or cli options such as KRITA_PORT for port and LISTEN_IP which sets the local IP to respond upon and KRITA_ADMIN_TOKEN, which provides an additional protection level when connecting

RAFT configurations like heartbeat timeout, election timeout and data size is defined with parameters such defined with the environment variable and will impact how fast it responds and scales across multiple clients in parallel

Cluster configurations allow a client or cluster node, for setting configurations and monitoring status across a set of connected hosts to ensure consistency

Logging parameters allows you customize verbosity to suit debugging, auditing and performance monitoring scenarios for each server peer and is defined by a set of environmental options and the file system

Persistence configurations for the location and file naming of logs and the actual key/value store. This will ensure proper data integrity, availability of logs for forensics and system health

Resource configuration allows one specify the resources for a host and is used as parameters, that is, the available storage for disk, CPU for the server to ensure that Krita scales well under a wide-range variety workload. For testing environments you want a low memory and storage size while for prod one needs a much better amount

You must also define a KRITA_ADMIN_TOKEN in order to perform administration operations such that the system doesn.t allow for un-authenticated connections and manipulation

To modify settings you only need to specify those that affect current runtime configuration while restarting all peers, for a full reset of the configurations for all instances and peers in your distributed system, a manual shutdown, rebuild with updated configs or Docker images

You may use CLI and ENV for different parameters depending upon preference. ENV provides an easy mechanism to pass values across the host and system and CLI is explicitly specified on runtime

## 5. Project Structure

The repository's organization fosters clarity and maintainability of our key-value database project:

*   **cmd/:**  Contains executable files - primary point of application and deployment layers such as Krita server `./cmd/krita-server`.  Includes administrative utilities.
*   **internal/:** Private project logic, not exposed for public use to avoid dependencies outside. This is the central business logic
*   **configs/:** Directory storing configuration samples as templates, which are utilized at start for server configurations such YAML formats, as required.
*   **api/:**  Interface wrappers around data and business objects to allow easier API access for external integrations.  Provides the abstraction needed to ensure code remain decoupled for better maintenance.
*   **src/:** Contains Go packages that constitute main business operations and functionalities of distributed system with core key functions. Contains peer implementations as needed, consensus implementations, hash ring logic and network transport implementations
*   **tests/:** Unit, integration and acceptance test definitions that provide quality validation, code verification as well automated execution to catch any unexpected failures or edge conditions as they emerge
*   **data/:** Data store for the task which can hold data for storage and recovery of states, which ensures durability and integrity when needed. Also includes log locations, and persistence.
*   **raft/:** Dedicated to raft protocol which allows nodes within to achieve consistent data replication, election mechanisms as part distributed consensus protocol to ensure system integrity across a range

`README.md`: Documenting instructions

`Dockerfile`: Configuration instructions, container build.

`docker-compose.yml`:  Docker setup for container orchestration and simplified deployment of all server components within the same environment and configurations as the host machine
.env docker configurations: Defines variables that will override docker configs, as necessary
## 6. Contributing

Contributions are very much welcomed, we want Krita open sourced and maintained in an accessible state to ensure everyone gets benefits. Feel free to submit pull requests, bug reports on any of existing features that could require additional development for a more streamlined operation. Please review these before contribution.

First, ensure to fork repository.  Then pull a local repository from github to allow local modification of feature. Create abstract and isolated environment, which avoids accidental contamination, as possible. Create separate feature branch from main and submit it back after code reviews have occurred with team

Please follow these contributing requirements; code standard using the `gofmt` for code style as per existing standards and test suite with adequate assertions and test code for ensuring code functions according requirements with high fidelity and confidence in the system as that evolves,

Submit your issue via github to track all open bug or improvement suggestions for future iteration as well provide feedback

Code must include comments when appropriate in all functions to enhance and aid comprehension and allow maintainability

Submit the test suite, and tests for any change. Debug tests with adequate assertion, to verify code functions. Please run `go vet`, before submitting.
## 7. License

Krita is licensed under the Apache License, Version 2.0. See LICENSE for details, for information about how this project will behave. It is open for public usage without limitation for most common production cases or commercial applications, provided the source and copyright statements included in source is respected for any derived or redistributed software packages and components

Usage without restriction and permissions, with exceptions and restrictions. Krita is a product, and it has been built using open sourced technologies to provide maximum compatibility, stability as part our vision and open-sourcing community as whole. We are always willing to help in the community. This is for general purpose of open community. Redistribution of copy and usage requires acknowledgement

General rights provided and obligations as well and the usage with proper credit for the open sourced technologies as it evolves,
## 8. Acknowledgments

We thank Google with it go libraries for allowing easy development. This is for a better and streamlined implementation. Krita's implementation is inspired and uses ideas from various research in the Distributed systems domain and the Raft papers by Ongaro & Stephenson. Without public open sourcing it cannot happen
Furthermore we want to thanks HashiCorp, as well and it configuration system which helped us achieve the configurations we are aiming at.

Many other resources and tools were invaluable: Go modules helped managing and ensuring correct library integrations

The Krita community itself - early adopters, contributors and feedback has guided its path to the system, that has allowed this software project, a great place and to have it here for open-source.

Open standards such HTTP for REST API operations have made integration seamless, for a greater number usecases implemented across many clients.

Finally, our software developers have given time in their life for building such a system. Without these developers Krita wouldn`t come out, for that our appreciation as a team.
## 9. System Architecture

Krita employs a distributed peer-to-peer architecture with the Raft protocol as a critical foundation of our implementation of this. A consistent hashing technique for efficient load balancing to distribute storage, where the nodes manage the subsets. The design prioritizes fault tolerance via data replication

The core comprises three principal entities : server peers , an administrator service & external consumers or APIs that interface the key-value stores as a function, and clients as part a request.

Client Requests reach one node within distributed cluster, which will act proxy on all peer, that holds keys. The nodes are responsible maintaining cluster integrity through RAFT algorithm and data integrity through data distribution as described above and data redundancy as possible. Each node in our implementation is independent to the others for a scalable and high availability environment. This ensures the Krita remains resilient to various failures in distributed nodes

Consensus mechanism is handled at the Raft implementation where leader selection happens to provide an authoritative point. A peer elected to leadership position ensures operations for cluster, with the nodes replicating changes to data stores

Data flow follows as key request to peer and is passed via a network channel, that ensures a reliable transmission of information and validation and storage, that guarantees integrity. This system provides high data-reliability as an overall design consideration
## 10. API Reference

The API exposes endpoints based upon HTTP. The following describes endpoints and their function to provide easy and reliable access:

**`GET /key?value=<string>`**: Retrieves value based upon supplied key string value as query
  * **Parameters**: value(required): key of object being retrived
  * **Response**: {status: success | error ,message} and associated body of response data in string form for JSON, as necessary. 200 if key exist 404 otherwise, with an empty payload as necessary
**`PUT /key -d "value=<string>"`**: inserts/Updates an associated entry.  Allows client for setting a new key to replace old value. Supports updating any key
   * **Parameters**: body(required) with `value=<string> for content to save
   * **Response**  status= "200 ok " if update occurs, with error codes displayed if the value isn invalid
**`GET /health`**: Checks if server node is available to process the data
    * **Parameters** No input params required for request
    * **Response**: status is " 200 if health" , 500 if something bad
## 11. Testing

Comprehensive automated unit testing has become a part integral of the project for validation

`go test ./...` to invoke the testing establishment for validation if test suite exists in current scope

Integration, and acceptance is part automated testing to check all components are integrated with high quality as expected and configured for proper operation

The server also provides automated unit checks via HTTP API tests which allows external testing from other programs that interface our system as possible and as well automated health monitoring to test availability on runtime. We provide automated integration with a Docker setup

Docker testing environment provides automated builds for each test to verify that build and deployment pipelines works properly
Ensure test configurations has the proper parameters, that matches production as necessary with configuration files that reflect the real production
We use the go built testing libraries and frameworks for testing to provide the automated pipelines
## 12. Troubleshooting

Connectivity Problems to nodes: ensure that port `KRITA_PORT` is correctly setup in host, network is correctly configured as possible to access the nodes from outside

High resource usage, ensure there`s sufficient memory on machine running server. Monitor resource usages as a result from system and reduce resources

Error 404: Key Does Not Exist; Ensure to verify if a given is key already present as possible on server, or the client request might misconfiguration or has invalid key as result from a human or system errors, which can result to incorrect request

Configuration Errors, double-verify all environment settings for configuration, ensure that parameters values have the appropriate format or are not incorrect

Raft leader Elections are in a stalemate - increase RAFT parameters like heartbeat timeouts if possible. Also doublecheck configurations as needed. Check system load

Network errors: Verify that nodes has connectivity as expected on their respective peers and ports

Ensure you verify error handling for logging purposes and that the logging has sufficient details for tracing causes in case any problem.
## 13. Performance and Optimization

Concurrency with go channels enables the system handling multiple read, right requests with parallel.  Cache is built with a memory based storage. Consistent has ensures a fast data routing and distribution as it evolves with increasing size in distributed storage. This provides faster key value reads in reducing time for look ups across all servers as it grows and evolves

The key design with distributed nodes is optimized with memory access to minimize the amount and complexity of transferring across multiple peers.  Also optimized to have data transfer over low latencies

Use benchmark suite that runs on different scenarios such key insertion rate, key lookup as a performance metrics against load on the servers to optimize system for various loads in parallel for increased capacity.  This provides an overview of where optimizations can come for further iterations of this key/value stores
Use monitoring tool, like `Grafana`, which provides real-time dashboards and historical metrics.  This tool assists developers and ops, as possible and helps them with the ability to analyze system bottlenecks as part an automated process.  Profiling and analyzing with go tools such like`pprof`, allows detailed breakdown in system bottlenecks as they happen and provide suggestions as it optimizes as a function and improves as needed for scalability
## 14. Security Considerations

All communication should utilize TLS encryption to avoid unauthorized intercept, especially if traversing network and especially with production environments to maintain system security with the best available encrypted protocols as an essential part to provide

Proper sanitization is important as a security protocol that is required for user input validation as to not create a system issue

All credentials for admin should not exist, in the public storage for safety and proper key protection for admin access
Implement role based and authentication as it grows as a function. It provides granular level security, access that only those who has level to manage it will
Keep libraries patched for vulnerability with latest available and automated builds for a better safety posture and reduce risk posture in all production
Security auditing for vulnerabilities as an on going task with periodic penetration as necessary, which identifies security and safety considerations to prevent attacks as possible for the system to operate safely as expected in all usecases and functions

Proper secrets are handled to ensure there's proper isolation with the keys and tokens.  Secrets is handled in KV stores to allow better rotation for keys and management, that are required
## 15. Roadmap

1.  Persistence - Implement data backup/recovery capabilities to improve robustness and durability in storage systems, to prevent system data loses, with an easy restore function as possible.
2.  Improved API endpoints- Implement more flexible endpoints. For data operations, for better and efficient usecases
3.  Data Encryption- Add in built in capabilities. To allow data in flight and in store, and encrypt it. With better data security protocols as possible
4.  Support Multi Regi