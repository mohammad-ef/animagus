# Simple Task Scheduler (STS) - A Python Task Execution Framework

##Description 

STS is a powerful, flexible framework designed to simplify and robust schedule execution of Python tasks. Its architecture emphasizes modularity, enabling the integration of different task backends and scheduler engines.  STS aims to streamline development, deployment, operations, monitoring, error management, and reporting of automated processes, reducing overall operational complexity and enhancing system robustness by managing task dependencies and error handling.

It allows for the scheduling of tasks based on a variety of time constraints - from recurring events to scheduled intervals. A core component of our scheduler is built with event queuing, ensuring efficient task delivery and minimizing delays.  STS is also designed to be extensible through a plugin mechanism, enabling users to add specialized schedulers, persistence mechanisms, monitoring and alerting integrations without altering the core codebase directly.

The framework's primary goal is to replace brittle ad-hoc scheduling mechanisms, such as cron jobs and basic loop scheduling, with a centralized, manageable, and resilient system.  STS supports a wide variety of task types, from simple scripts to intricate database operations with the added benefits that include automatic retries, error logging in a centralized location that supports alerting. It's particularly well- suited for automation in cloud- native systems or applications. 

STS is built for easy operation, monitoring & integration, featuring REST API for remote task creation, modification. It supports a wide range of persistence and scheduling mechanisms, including in memory for simple tasks and persistent queueing (Redis/ RabbitMQ) for complex production environments requiring robust failure resilience.  STS provides a comprehensive and extensible architecture to handle the needs of any automation workflow, and is designed to scale and adapt alongside your needs.

STS also offers comprehensive task dependency management ensuring tasks run in the correct order while handling failures appropriately. The task execution can be logged into the system for debugging purposes. STS is also designed to integrate with a wide range of monitoring tools for proactive alerting. STS is also designed to allow developers to add more task types easily.

## Installation Instructions

To begin with STS, you will need Python 3.7 or greater. It is highly recommended to use a virtual environment.

```bash
 python -m venv sts_env
```

Activate the virtual environment:

  *   **Linux/macOS:** ` ./sts_env/bin/activate`
  *   **Windows:** ` sts_env\Scripts\activate`
    
STS primarily uses `pip` as its dependency resolver and installer. You can install the package with the following command using `pip`:

``` bash
 pip install SimpleTaskScheduler
 ```

Make sure your `pip `is upgraded as well before installing the STS package: `pip install --upgrade pip`.

This installs all the required dependencies, as specified in the `requirements.txt` file within the project. The project requires that you have python 3. 7 or greater.  This can typically be downloaded and installed directly from python.org.

If you have a proxy configured and `pip` does not work correctly, ensure the necessary environment variables `HTTP_PROXY` or ` HTTPS_PROXY `have been appropriately configured with the proxy server and port details. 

You may also consider updating `setuptools` before proceeding with any installation to ensure a successful install: ` pip update setuptools`. It is possible that you also may need ` build essentials`, this can be fixed installing with command ` apt-get install build-essential` for Debian-based systems, or equivalent on different platforms. 

If the install fails, make sure the correct Python version is selected, and the environment variables (particularly PATH) are correctly configured. Check your Python installation's location and update the relevant environment variables accordingly.

## Usage Instructions

After a successful installation, you can start scheduling tasks using the STS API. First, import the STS core components:

  ```python
  from sts.scheduler import TaskScheduler
  from sts.task import Task
  from sts.config import Config
  ```   

Create a basic task:

```python
 task = Task("my_task", "my_module.my_function")
```
   
The function that will be passed into the system, has names as key value pairs for import paths

Configure a simple scheduler, which uses In-Memory queue by default, for config options refer configuration documentation.
  ```python
 scheduler = TaskScheduler()
 ```

Add and schedule the task. 
```python
 scheduler.schedule_task(task)
 ```

This will start the task scheduler loop running which handles events and runs jobs. It also handles additional scheduling parameters like retry logic in error situations, timeouts on execution and so on.
The system offers additional methods such as `get_scheduled_tasks()` that retrieves tasks for display as needed for reporting.   
    
You can use more sophisticated schedulers such as RedisScheduler if needed with additional imports to the ` scheduler`, as described below, with configuration to the `scheduler`. This also handles persistent job scheduling in the queue to be handled by future jobs as they start to queue for scheduling in production settings.  The framework offers comprehensive API features that provide detailed task control, logging and status reports on tasks for management and troubleshooting in various module operations,

## Configuration

STS offers various options for configuration that are managed through both an in memory configuration file that is created by code during execution or via ` sts.yaml`.

To change scheduler behavior (for example to switch the queue type or change error management) edit your configurations to reflect changes to your scheduler needs

You can create or update your own ` sts.yaml` by defining a file at project startup that allows the STS module to automatically configure and initialize its internal configurations as a module and load into an environment as a code configuration variable as described in documentation below

Example `sts.yaml` configurations

  ``` yaml
   scheduler:
      queue_type: redis
      redis_host: localhost
      redis_port: 6379
   task:
     max_retries: 3
     retry_delay: 60
     log_level: INFO
   ```

Environment variables will always take precedence when initializing an instance of ` STS Scheduler`, if a environment configuration setting for any of the above variables in a yaml is specified.  Environment configurations will automatically update as variables set within the system during execution as the system re-instantiates the scheduler

For instance, using a configuration environment:  Setting variable for redis configuration ` FORCE_REDIS_ENABLE` allows the configuration module to load redis configurations when initializing and scheduling jobs using redis queue management for immediate scheduling persistence during job execution in an environment as an option. This is configurable and can automatically switch based on environmental conditions to load configurations and queue jobs accordingly during runtime of an event execution.
      

## Project Structure

The project consists of the following directory structure:

*   `sts/`: Root directory for the STS project.
    *   `scheduler/`: Contains the task scheduler core logic and scheduling engines.
    *   `task/`: Defines the Task model and associated classes.
    *   `config/`: Handles configuration management, and configurations for different queues or event management engines,
    *   `tests/`: Directory for unit, integration, and end-to-end tests.
*   `examples/`: Sample usage scripts and tutorials.
*   `docs/`: Documentation.
*   `README.md`: This document.
*   `requirements.txt`: List of dependencies.
*   `sts.yaml` configuration

Each subdirectory provides code options and tooling, allowing flexibility during deployment to ensure all environments are handled as intended. All configuration and module paths for scheduling queues will allow seamless and rapid scaling of environments to allow scheduling jobs at scale across different environments to be handled seamlessly with the scheduler engine and modules

## Contributing

We welcome contributions to STS! Please follow these guidelines when submitting changes:

*   Report bugs and feature requests through the project on github or the issues tab on GitHub. This helps track issues systematically and provides clear guidelines.
*   Create a new branch for each contribution: use this approach for all new code contributions as this provides isolation of development environments that will prevent any disruption during integration into core project environments and installations
*   Ensure that your code follows our coding standards, using linters or other tools, and please follow the established patterns of code structure to improve project understanding during contributions from the developer side of project environments
*   Write unit tests for any new code, which allows rapid deployment for integration purposes during development as well for future code updates or improvements and ensures proper handling and execution across various configurations,

## License

STS is licensed under the MIT License.  This permissive license allows for free use, modification, and distribution, whether for commercial or non-commercial purposes. It's also intended to promote community involvement by ensuring that all code contributed by external collaborators will have access as well and promote community adoption across development environments. The MIT license grants you freedom to do so with very little obligations or requirements.
   
## Acknowledgments

We extend our gratitude to:

*   The Python community for providing a versatile and thriving platform for developing such software solutions, ensuring seamless code compatibility, integration with external frameworks.
*   The creators of Redis and RabbitMQ for the powerful queuing systems underlying the flexible persistence mechanisms that the task management can handle in environments with a focus to allow scheduling of tasks and event processing as required by various applications to provide scalability in environments requiring elastic processing abilities

## System Architecture

STS is composed of several interconnected modules working together to achieve robust task scheduling.  A core component includes task definition modules for task descriptions and parameters for configuration of various task requirements such scheduling times as an initial requirement.  At a system-wide layer a `Scheduler` core that is configured by a queue engine for processing events.

A high-level representation of STS architecture involves:

1.  **Task Definition**: Defines and stores task attributes - such as ID, name, module import paths with a given functions.

2.  **Scheduler Engine**: This handles time event and task execution and handles all persistence requirements. This module uses various plugins, which handle various types of events, queue events with scheduling.

3.  **Queue System (Persistence layer)**: Queuing events allows scheduling events with robust error checking and recovery mechanisms in an elastic scalable event management environment as part of a broader scalable infrastructure, such as with cloud services and container deployments with auto scale requirements that will scale or shrink dynamically in the environments where scheduling is needed and is a required aspect in most applications requiring event-processing

## API Reference

STS offers a comprehensive REST API to create, list, retrieve, update, and delete tasks and schedule operations.  The REST endpoint supports standard methods like GET, POST, PUT, and DELETE for each operation with the following API endpoints that will facilitate integration for any event queue operations with management as the primary goal and purpose in most cases with various scheduling integrations and configurations, such as using RabbitMQ

1. /tasks  -- (Get, Post), list or create
2. /tasks/{id} -- (Get,Put,Delete), get individual, updates tasks
 
Detailed response codes (i.e, successful operations as defined by API statuses).

Example - Create Task via Post:  POST /tasks

  `  {"name":"example task","schedule": "10:00AM","function":"my_module.execute_example","taskid":"01a"}`, will trigger the schedule with all necessary configuration details, including scheduling parameters that are configured in YAML configurations

## Testing

STS has thorough unit tests and a framework is defined with a test suite to allow comprehensive tests during module creation as an automated integration into development environments as an optional but required aspect during project integration with the code modules, to test functionality as well

 To run all unit tests:

  ```bash
 pip install pytest # If pytest is not already installed
  pytest tests/
  ```

The unit testing frameworks are also designed with an integration with CI to handle code builds, automated code review as the system integrates modules to the project and provides immediate feedback and alerts during the testing processes.

## Troubleshooting

Common Issues and Solutions:

*   `ImportError: No module named 'sts'`  - Make sure that the virtual environment is activated, if using and you properly ran installation of dependencies beforehand in environment setup as part of initial environment preparations
*   `Task execution failed - Connection Refused to RabbitMQ`   Verify RabbitMQ service has been initiated with configuration and that credentials in your yaml config settings match credentials in server
*   Scheduler Failed during initial run-check for missing modules

## Performance and Optimization

Performance considerations are key. For very high-throughput task schedules, we advise using `RedisScheduler `as an alternate persistent scheduler to provide increased processing throughput for handling larger numbers of concurrent scheduled operations in production

Caching is implemented on the scheduler layer where the queueing and task processing events happen

To analyze the overall scheduler processing on CPU load, and performance on I/O events we support standard `profile tools in Python ` such profiling can provide valuable debugging data for optimizing code performance.   These insights help developers fine tune their scheduling logic

## Security Considerations

Secrets (like API keys, database passwords) shouldn&#x20;
_ not _ be stored directly in code or configurations within git. Utilize environment variables to manage secure credentials or secure credential manager systems such as with vault.
Input validation: Thoroughly validate any external inputs passed to scheduled tasks or APIs and apply appropriate validation to mitigate injection risks or other malicious attacks to protect data, and the overall environment during operations of event management

## Roadmap

*   Integration with other notification service, to add alert functionality on job failure/status

*   More advanced job chaining

*   Enhanced GUI

## FAQ (Frequently Asked Questions)

*   Q: "What types of scheduler can STS be used?"  
A: "It uses various scheduler implementations like Redis Scheduler to manage jobs as needed by users in a defined configuration.  It also allows for memory queues."

*   Q: Can STS integration with CI build tools such as with Jenkins and github action

A:   Yes STS has been developed and designed as integration- first framework that integrates directly across various tools in the DevOps space and provides automated deployment to production systems and can be extended through plugin modules to create and automate custom CI processes for any build tool

## Citation

To cite STS, use the following BibTeX entry:

```bibtex
 @software{SimpleTaskScheduler,
  author = {Author Names},
  title = {Simple Task Scheduler},
  version = {1.0.0},
  year = {2024},
  note = {GitHub repository: [link to your GitHub repository]}
 }
 ```

Proper credit to acknowledge contribution from project contributors, to enable proper documentation for research or use in various environments is an intended function in providing clear visibility into contributors involved and code usage

## Contact

For questions, issues, or collaboration opportunities, please reach out via:

*   Email: sts.project@email.com
*   GitHub Issues: [Link to your GitHub repository]
*   Forum/Community channel. (add url to relevant discussion channels and or alert services).