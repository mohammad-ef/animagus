# Simple Task Scheduler (STS) - A Python Task Execution Framework

##Description 
STS aims to simplify and automate task execution in projects requiring periodic or timed jobs. This project provides a lightweight, customizable framework for scheduling and running various scripts, functions, or processes. It supports various scheduling triggers like interval- based, cron-expressions and manual invocation providing flexibility.

STS is built using Python and leverages `asyncio` for efficient execution. It is designed to be modular and extensible allowing users to easily integrate different task types and scheduling strategies. This framework is ideal for developers who seek a straightforward method to incorporate job management in their applications, eliminating the need for complex external services.

Key features of STS encompass a task registry, scheduling mechanisms and robust retry logic. The registry provides a centralized storage system for managing tasks. Furthermore, its retry capabilities ensures resilience against temporary errors and intermittent connectivity challenges.

STS minimizes resource impact by using an event loop, and it is optimized for low- latency scheduling while providing clear logs. It supports custom tasks written in Python or can be easily extended to handle external executable files or commands.

This scheduler can also be easily integrated into various projects - from data ingestion pipelines to system monitoring. The design prioritizes easy usage for both beginner and advanced programmers. STS is a tool designed to improve project efficiency. 

## Installation Instructions

Before proceeding, you' ll require a Python 3.7 or greater.  It can be checked by typing `python3 --version` at the command prompt.

STS depends on the asynchronous programming environment in built in Python which means no explicit installation. It relies upon asyncio, a native module of Python 3.

First, create a virtual environment to isolate project dependencies. This command creates a new directory "venv" in your current directory and initializes the environment. `python3 -m venv venv`

Next, navigate into the newly created environment. The command `source venv/bin /activate` is used on Unix based system (macOS/ Linux) to activate the created virtual environment. For the Windows, run `venv\Scripts\activate `

Now the installation of STS can be done using pip.  The command `pip installer sts --upgrade ` will install and upgrade STS to the latest available version. It is highly encouraged to use `--upgrade`

STS relies solely on Python and does not demand the usage of any specific external packages beyond those built into the standard library.

Finally, ensure your system has write permissions to the environment to properly write the STS libraries and their requirements. Check that you're using a user-friendly editor or IDE to easily modify and execute Python code. 

## Usage Instructions

To start, you need to import the `Task Scheduler` and `Task` classes from the `sts` module. In a Python file, write: ` import sts `

Create a task by subclass from the base `Task` class. You can define a method called `run`, which is the method that will be automatically called when the task is triggered.  Example: ` class ExampleTask(sts.Task): async def run(self ): print("Running example task")`

Add the task to the scheduler using the `add_task` method.  Example: ` scheduler =  sts.Task Scheduler(); task = ExampleTask(); scheduler.add_task(task)`

Run the scheduler indefinitely with the ` run` method. This will start the scheduler and execute tasks according to their scheduled triggers. Example: ` scheduler.run()` which will start the scheduling loop.

You can also schedule a task to run at a fixed time interval using the `schedule at` method. `scheduler. schedule_at(task, "10s")` will cause the task to run every ten seconds. This offers flexibility when timing is critical for task completion.

For more advanced use, explore cron expression scheduling with `schedule_cron`. For instance, `scheduler.schedule_cron(task, "0 0 * * *")` will trigger the task every day at midnight. 
   
The STS framework is fully asynchronous. The `run` method blocks execution until the scheduler is stopped. This behavior can be modified by setting the `blocking` parameter during instantiation to false.

## Configuration

STS relies on environment variables to configure its behavior. The `LOG_LEVEL` environment variable controls the verbosity of the logging output. It can be set to 'DEBUG', 'INFO', ' WARNING', 'ERROR', or 'CRITICAL'.

By default, STS runs in a blocking fashion. To change this behavior, the `BLOCKING` environment variable must be set to either True ( blocking mode) or False (non-blocking mode). When False, it is ideal when integration in applications with event loop or non- blocking behavior is desired.

To customize the logging configuration directly, the `LOGGING_CONFIG` environment variable can hold a file path that defines detailed settings. These include setting format, loggers and handler levels, giving more granular log configurations

Furthermore, tasks might contain individual settings, that are passed into the Task during the addition step in STS `Task Scheduler`. For instance a retry strategy could be passed into tasks that would handle temporary exceptions when they occur.

The scheduler is also equipped with default configuration parameters like ` max_concurrent_task`. If it does not find it on configuration file it sets its own, to avoid errors, while maintaining a consistent operation mode across runs. 

## Project Structure

```
sts/
 |-- __init__.py   # Initialize the sts package
 |-- task.py        # Defines the Task class and associated functionalities.
 |-- scheduler.py   # Implements the TaskScheduler class.
 |-- utils.py       # Includes various utility functions.
 |-- tests/
      |-- __init__.py
      |-- test_task.py  # Tests for the Task class
      |-- test_scheduler.py # Tests for the TaskScheduler class
```
The root directory holds all core modules. It consists mainly of a set of Python scripts. Each python script represents one part of the task and provides functionalities and configurations related to them.

The  `utils` directory contains several utility and helpers.  They support different operations of Task scheduler like data conversion or string manipulations used through other STS files.
`task.py` file holds primary Task base classes with methods related to running task configurations or retry mechanism

Tests resides under `tests`, and includes several tests with `pytest`. `test_task.py` focuses specifically testing functionalities in its task file `task.py `, ensuring proper behavior while interacting tasks configurations and execution flow
`scheduler.py` file houses the logic required when running or stopping of scheduler loops with different execution models (non-blocking or blocking) as configured with env variables
Finally all modules import each other as necessary in its implementations and the root project has the init module

## Contributing

We welcome contributions to STS.  First, create a fork of the repository on GitHub. This action creates your copy to make your own changes without altering upstream version of source files

Clone the forked repository locally using `git clone <your_fork_url>`. Now that you copied your version on GitHub clone this copy to locally to your system for modifications and improvements

Create a new branch to feature development, for better separation between development and release workflow: `git checkout -b feature/your-feature-name`. It ensures clean commits for each new task to improve version managing workflow.

Follow our coding standards - Python PEP8 - which are described with linters like Pylint for consistency. Also make sure you provide adequate testing and ensure existing code works without regression while testing

Test any newly developed components and fix existing issues or create bugfixes before submission by adding comprehensive test files for your work with `pytest` for validation purposes. Ensure that existing functionality still functions appropriately without regressions
Submit a pull request to the main repository from the created feature branch, including descriptive title explaining your contribution, and commit messages explaining changes and logic behind it

## License

STS is licensed under the MIT License. 

This means you're free to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of STS.  

The terms state explicitly in the full licensing agreement, it can not be held accountable and liable from misuse, and the distribution or sale with no attribution is allowed as stated by this. Please view full terms at <link_to_mit_license>.

## Acknowledgments

We thank the entire Python community for building such an exceptional and versatile programming language.

STS heavily relies on Python`s standard libraries for its operation - especially asyncio - making development simple.  Also the `pylint` project which allows code analysis for PEP8 compatibility

Additionally we acknowledge support of various online sources that helped with the development and provides useful resources for the implementation and best practices to achieve this scheduler, especially in areas around error and event handing

This tool is created as a part of an internal effort within <team> - with support for its team to provide and maintain an open source framework.

## System Architecture

STS architecture focuses around Task, Task Scheduler and utils module which work together with a centralized configuration. Task represents single jobs. The task can define running behavior as needed and can include settings and retry capabilities as needed
Task scheduler takes responsibility scheduling execution tasks, based in configuration parameters, scheduling trigger, retry strategy when it comes up, and execution.  Also maintains and registry task list that provides an efficient means and tracking all configured and added jobs

`Utils` modules provides several reusable helpers and functionalities to help both other core elements as also to the users.

Task are managed in an asyncio environment. `Scheduler` contains an event loop which triggers the scheduled executions and provides concurrency to run all scheduled job

All of these components operate based on an configurable set. All configurations are set on environmental parameters which allow for customization without code changes as well.
All the components can run as an async code, with no external threads and with no extra processes, minimizing its resources consumption

## API Reference

`TaskScheduler`:

`add_task(task)`: Adds a new task to the scheduler
`remove_task(task)`: Removes task if exists on the registered Task List. 
`run()`: Start Task Loop, executing the scheduled Task

`Task` class:

`run()` : Method triggered whenever scheduled. Must have this implemented and return a `coroutine` that is the actual task execution to occur in async flow.

Configuration options (env variables):

`LOG_LEVEL`: Log verbosity
`BLOCKING`: Controls scheduling behavior as an asyncio code (true, false)
`MAX_CONCURRENT_TASK`: Limit on how many jobs will happen concurrently on task scheduler 

## Testing

To run tests use: ` pytest` in the main directory with your environment already running
`TestTask.test_running` will ensure running behavior on task and proper configurations on Task 
`TestTask.TestScheduleCron ` validates correct execution and behavior using the schedule function on the `TaskSchedules`. This validates time management 
 `test_scheduling.py` includes multiple checks and assertions that confirm the TaskSchedulers and it functionalities run smoothly as defined by configuration settings. It validates different scheduling models as non-blocking behavior on the loop scheduler


## Troubleshooting

Issue: ImportError: No module named 'sts' - ensure that environment virtual is correctly active and the installation steps procedure. It can usually solved on checking if virtual environmet it's enabled and if pip was configured in the active path of the virtual environments . If you are still getting issues check for conflicting installations on system and use `--force-reinstall` in installation commands if the case happens

Problem: tasks are not firing - Verify scheduler running in interactive shell or in an environment. It can be also caused in configuration issues - Check the env configuration or parameters, make sure they set as desired in Task configurations, especially when using time-dependent or scheduled intervals in execution

Bug : Excessive resource usage when task are triggered.  Ensure the number `max_concurrent_task ` does not go overboard with number jobs triggered to reduce resources, optimize task code by limiting external requests if possible
Issue : Task does not get logged, ensure `log_level` set correctly with a higher verbose level if not getting information or debugging mode, and that logger properly setup in your application


## Performance and Optimization

For performance tuning reduce external resources usage. Avoid database interactions where not critical by using cache mechanisms
For heavy workload implement `asyncio`, using asynchronous tasks. The asyncio is designed and implemented with a minimal resources footprint
To handle larger scale, consider the utilization and scaling capabilities of your task, especially with large number job executions to avoid resource contention. 
Consider utilizing multiple cores or parallel execution jobs to speed tasks and minimize execution durations if it's an application dependent


## Security Considerations

Protect the keys by utilizing env configuration or dedicated key managers when accessing secrets like DB pass. It avoids sensitive details into application
Input Validation for tasks must ensure data are validated properly when received before usage in code
Ensure the code follows proper exception handling to mitigate potential injection and other malicious attacks.
Regularly scan for and fix dependencies using appropriate software updates as needed and stay abreast of any discovered vulnerabilities 


## Roadmap

* Integrate persistent Task Storage - Store tasks into the DB for persistent management, even with scheduler restarts
*  Enhance Monitoring Dashboard  Build an interactive web UI showing real time metrics, running statuses on Task scheduler with configurable graphs and reports
* Multi Thread support to enable more parallel tasks execution, tackling performance issues for large job workloads - enable more core usage to speed tasks up. 
* Task Chain capabilities. Create task dependency chains that can define execution workflows between jobs 
* Advanced Scheduling Options - Integrate complex trigger like window and calendar base triggers



## FAQ (Frequently Asked Questions)

Question: Can I use custom code for Task execution instead using native `sts ` task ? 
Response : The Task module serves as an interface to run any Python-native functions to create tasks without needing extra imports 

Issue: I have problems installing `sts `? Check for missing packages and that environment activated correctly by executing installation steps again 

What if my environment doesn\'t run properly and fails with error code when installing packages - try uninstall existing installation to clean environment 

If tasks does not fire on schedule, double-check scheduling configuration - check env variable configuration with correct cron- expressions and interval values and also the Task configuration



## Citation

To properly cite Simple Task Scheduler in academic work, please use the following BibTeX entry:


```bibtex
@misc{SimpleTaskScheduler,
author = {Your Name/Organization},
title = {Simple Task Scheduler (STS)},
year = {2024},
note = {GitHub repository: <Link to the repository>}
}
```

Replace Your Name/Organization with corresponding names/organization, update Year, link accordingly and ensure to update the URL in GitHub to your project link, if different, to correctly represent your usage 

## Contact

For communication about this task please email  developer at  test email. Please submit all issues via our issue management page in this Github Project Repository
If issues still exists please create tickets, to better organize all open problems 

We welcome feedback! We encourage all the user contributions through this Github repo, so use your freedom on contributing with improvements
