# Simple Task Scheduler (STS) - A Python Task Execution Framework

##Description 

STS allows you to schedule and manage tasks efficiently, running them in a specified order at determined periods. Its core strength is its lightweight nature and ability to adapt to simple or sophisticated workflow scenarios. It' provides a clean and flexible framework for scheduling scripts, commands, or any callable function. The architecture uses a configuration file defining the tasks and their schedule in a clear, human friendly structure. STS provides basic logging features, to aid debug.

STS is intended for situations requiring automation of repetitive tasks such as database backup routines, system monitoring or scheduled script deployments. Its simple dependency setup allows ease of adoption on a number of platform environments without requiring large dependency overheads. The framework is designed to be extended, enabling custom scheduling and execution policies. Future development will consider more elaborate monitoring and reporting features.

The scheduler core utilizes a timer-based approach, periodically checking the task list against the system time.  Scheduled task definitions are loaded from a JSON configuration. The task execution is handled within a dedicated process, isolating scheduled operations from other application processes. Error reporting is basic, logging errors to a standard error location for debugging.

STS is written entirely in plain Python to ensure wide platform compatibility. While no database is required, the configuration files should be stored and protected to secure the scheduled processes. The scheduler core is relatively small, making integration into existing systems straightforward. Its modular structure allows for future enhancements, with the aim to expand functionality as needed by developers and users. The framework's focus is on stability and simplicity of use.

Currently, STS is primarily designed for single server or standalone machine use. Distributed schedulers or complex orchestration are outside the scope of STS's original goals. The project aims to be easily deployable using container technologies such as Docker, simplifying the deployment of scheduled workflows. It is an ideal solution where you need a simple way to ensure tasks run on a regular basis, but with minimal dependencies and overhead. STS is a starting point for automation.

## Installation Instructions

Firstly, you need to make sure you have a Python environment installed on your system. A recommended version is Python 3.7 or above, but most Python 3 versions should work fine and will be compatible. The STS core only uses built-in Python functions, so it requires no external C/C++ compilation. Python can be typically found in most Linux and Mac OS distributions. Windows users may consider using Python installed in conjunction with the Anaconda suite.

Next, you need to obtain the project code. You can either download a ZIP archive from the project's repository or you can clone the GitHub repository directly using `git`. Cloning is the preferred approach for tracking changes and contributing updates. You can clone the repo using:

```bash
git clone https://github.com/your-username/sts.git 
```

Once you have obtained the code, navigate into the STS project directory in your terminal or CLI environment:

```bash
   cd sts
```

After you've entered the repository you should see a `setup file`, usually called `setup.py `. You need to run this setup file to install STS and its dependencies: The setup file contains metadata about the project and the instructions for installing the Python packages. The recommended command for this is:

``` bash
     pip install .
```

The above command should install the STS core and all dependencies specified within the `setup.py`. On some systems, you might need root or administrator privileges for this command to execute correctly. Use `sudo pip install .` on Unix-like operating systems, but be careful when using `sudo pip`.

If you face any problems installing, it is often due to a pre-existing ` pip` installation. You should check the ` pip --version` to see your ` pip` version. An out-of-date ` pip` can often cause installation conflicts. You may need to run ` pip install --upgrade pip `before continuing the install procedure. 

If installing using pip doesn `t work, and there might be permission restrictions`, try a `virtualenv `. This approach ensures STS runs inside isolated env that don affect system installations: Create the `virtualenv`:

```bash
     python3 -m venv venv
     source venv/bin/activate #on Mac and Linux.  on windows run `venv\Scripts\activate`
     pip install . #inside the active virtualenv
```

After installing, check whether it installed sucessfully.

## Usage Instructions

To effectively schedule a simple script execution using STS, the initial setup consists of crafting a basic task scheduling configuration in a `json` file. The json configuration file contains tasks which are executed based on their scheduling criteria specified in it. An example file looks like below

```json
[
    {
        "name": "backup_db",
        "command": "python /path/to/backup_script.py",
        "schedule": "0 0 * * *"
    }
]
```

Where "backup\_db" denotes the script being run , and `0 0 * * *` corresponds to the standard `crontab` cron-schedule for periodically invoking that process: At midnight, daily, without a particular weekday specification. The script will get exectued at that point. 

To use STS: Save the example as "tasks.json" (or choose your preference) alongside the python source script (`sts.py`) Then, you should invoke STS from the command line as follows:

```bash
   python sts.py tasks.json
```

If `sts.py` cannot read from the `tasks.json` then an appropriate warning is displayed: Ensure that your JSON file path has a path for your environment and also it contains all the cron schedules and task paths as needed

For an extended use-case consider defining several scripts to automate several jobs. For that purpose a more advanced config could contain the following

```json
[
    {
        "name": "daily_cleanup",
        "command": "python /scripts/cleanup.py",
        "schedule": "0 2 * * *"
    },
    {
        "name": "update_status",
        "command": "python /scripts/update_db.py",
        "schedule": "0 6 * * *"
    }
]
```

You should always test any scheduled tasks carefully on development and QA environtments to check if everything gets configured according to requirements. STS does log its output, however there aren more detailed system-wide reporting tools you may be required for a robust implementation of job management tasks. Also you could modify and enhance sts.py for custom behavior if you have advanced task management and scheduling scenarios.

Running STS for an extended duration will continuously parse your json file, execute any task and continue. To ensure stability use appropriate environment variable separation for the task definitions and the script to prevent data leaks from task descriptions in logs. It `s advisable that each job` is contained by an individual process and does contain its appropriate error reporting so as that debugging gets simpler in the end

The program runs until the user sends the SIGTERM to its parent or its internal process stops execution and throws exceptions . The best is for long execution cycles, a process is set for long cycles. Do monitor logs, to ensure that jobs do not hang due any errors or other problems in their configurations.

## Configuration

STS primarily uses a JSON configuration file (`tasks.json` or specified via command-line argument) to define scheduled tasks. The `schedule` field within each task object uses a standard cron-like syntax to dictate when the task should execute. This syntax allows specification of minutes, hours, days, months, and weekdays for flexible scheduling, similar to how crontab is specified in many *Nix-systems. Each of them should align in order to be effective, or STS can have problems reading and processing task data from JSON configs.

For example, `"0 0 * * *"` specifies a task to run at midnight every day. `"*"` matches any or all possible inputs and allows the task definition flexibility with scheduling parameters, for the cron schedule parameters, it matches a day, weekday or other schedule component respectively

The `command` field holds the absolute path to the script or executable that needs to be run. Relative paths may resolve incorrectly if executed outside the current directory or under system environment variable constraints so be mindful.  Ensure you are passing correct permissions and configurations when the running process does require them. The script itself should be idempotent - it should not have side effects if the schedule repeats

Configuration can be augmented using an ENV_VARS to modify parameters that get passed in. These parameters could contain credentials, file location information that can modify what task is executed. Usually they are passed to tasks to prevent secrets in the task configurations and ensure secure operation and separation from configuration file. This separation is critical if you want sensitive parameters such as secrets anywhere, especially in production or in sensitive envrionment deployments. For a production implementation consider setting up appropriate permissions. 

For custom scheduling, a new scheduling policy implementation may have to extend `base scheduling` with an inherit or custom class implementation which can provide custom and advanced logic, but that requires code modification in python itself to handle such requirements in scheduling logic in `STS`, for future implementation enhancements or expansions to handle such usecases

You should ensure configuration file access control, since unauthorized edits in config file parameters might cause unintended behaviors that might affect your environment or other scheduled jobs

## Project Structure

The STS repository follows standard project organization patterns:

*   `sts/`: The main directory containing all the project files.
*   `sts.py`: The core STS script responsible for loading configurations and scheduling tasks. It `s also an API for scheduling.
*   `tasks.json`: A JSON-file that serves as sample and provides the tasks definitions. Can get overwritten if desired to reflect custom definitions
*   `README.md`: The file describing how the project work
*   `setup.py`: Contains the information needed for building ` pip`- packages to be built in STS

It also contains `test folder`, to test if `STS.py `is performing all of their expected functionality: This area is critical to verify correctness during modifications
This structure makes the code well-organized with the separation between project source script code base to configurations for the jobs in the scheduling process: It ensures separation from configuration for clarity when running, as it provides separation

## Contributing

The success of STS greatly relies on a committed open source contributors community . Feel free to provide feedback. To help improve the framework and submit contributions.  First report a bug through Github Issue reporting. Be specific with what environment and configurations cause problems in STS and try reproducing with an explicit step and environment. The team values concise error-tracking information, that enables the contributors in debugging the problems quickly .  Also please check to be certain no bug-fix or feature exists before opening.
If submitting feature enhancement, be specific of your requirements and provide the rationale that it adds value for other user needs or the existing configuration requirements in existing implementations . 

For pull requests follow these general standards and conventions, as well : 

    Always add comprehensive unit test code, as to increase robustness for future enhancements in scheduling. The `test/ ` directory serves that goal to contain testing implementations of the scheduling functionality.  Ensure they execute successfully
    Follow Python code guidelines - such that the source code adheres with style conventions in code and the formatting in `pep8 `. The `STS `.vim-files contain formatting as such to aid consistency across implementations 
    Add proper documentation as well. If modifying an exposed ` api `. Make appropriate documentation as to enable other developers in usage, expansion to ` API`. Ensure documentation follows scripting style conventions as `docstring `, to aid clarity

## License

STS is licensed under the MIT License.  You are free to use, modify, and distribute the software, whether for commercial or personal purposes, under a very few constraints as defined with this licensing. Please review and comply to this terms before any usage, distribution as such

## Acknowledgments

STS has heavily leaned and borrowed principles from numerous existing cron scheduling libraries for *Nix platforms: Specifically the standard crontab system, to enable similar cron scheduling capabilities. Also Python libraries are heavily influenced and utilized, such as JSON parsing and standard python file system utilities

Also, a significant thanks to Python developers for developing `PIP`- and related utilities such that the code distribution is seamless: Also many open sources frameworks, which serve inspiration on modular design and minor task schedulers and implementations in similar use cases are greatly inspired by this framework

## System Architecture

The core system comprises several components: A Scheduler core that runs periodically checking and executing jobs based on configurations and JSON definitions, task runner and an output manager which logs results or sends error notifications in execution

STS operates with `JSON task descriptions`: the JSON descriptions are used for task definitions for execution, and scheduling based off configurable time-schedules in each of their JSON objects . This enables modular task configurations without hard dependency constraints: a core task is initiated, then executes the command as defined by task configuration: If an error exists or if execution goes sideways it sends error reports. The task definition and its parameters do exist separately

The overall design ensures flexibility, scalability as task definitions can grow separately in a non intrusive approach, allowing expansion. Also this approach minimizes interdependencies between the scheduling components: with the core scheduler running separate to each scheduled script or function, additionally it isolates errors in tasks and minimizes impact in the scheduling processes . Also ensures a separation with the components

## API Reference

STS offers minimal exposed ` API `. Its ` primary API` revolves through calling function and parsing json configs from the python scripts itself to run a scheduling.  For extended functionality and custom behaviors you need custom `python` scripts

Here the key methods in running a schedule :
`STS.scheduleTasks (jsonPath):  Load configuration in JSON at the `jsonPath `, schedule the configurations based upon their scheduling specification and run
STS .stop ()`: stop scheduling processes

These two APIs expose most scheduling requirements. More advanced scheduling logic can involve expanding those `functions `. For a robust implementation a scheduler may need an enhanced configuration file to manage multiple parameters that affect performance in task runs as described

## Testing

Unit and end-to-end testing plays critical roles and it ensures code correctness as you extend and expand STS functionalities. You need test SSTs.Py, as its critical for correctness to execute and parse schedules in a proper format

Tests should run with a `pip install test `.

Running test suite:
` pytest ` (or a preferred ` test framework`), will trigger the test and show the output. The tests can simulate fulfillment and failures for task executions as you test different configurations. Also ` pytest - v `, shows the full output of tests.  The output will show you which ` STSTest cases `, execute successfully. You may have a separate environment and dependencies, for tests: Ensure all are in `test requirements ` for proper dependency resolution when running your suite `pip install-r test/ requirements.txt`.  If your implementation is running and the tests passes that implies it's correct

## Troubleshooting

Encountering `json` parse problems: Verify if task file follows a valid schema in your file: Check file permissions or if all file access rights have a permission that `STS`, needs
If the schedule `doesn't` match the `current` environment. Double verify `time zones`.

Ensure all file and scripts specified within tasks configuration file has absolute or appropriate `working directories.` Check all environment parameters and credentials in JSON are accessible. Verify all permissions in files are properly managed in execution

Encounter an environment where you get error logs or failures during `API `. Check `error-logging and `stack_ traces `. If all file-transfer operations failed to resolve the `dependencies `. Try reinstall with virtual ENV to prevent ` dependency issues `. Ensure all external processes do work and the scheduling system is able to trigger and execute external dependencies and it is not restricted to any access rights and permissions
Ensure the task does get triggered by executing them by `hand`. This is often easier

## Performance and Optimization

Consider using optimized ` python` code, such to reduce task scheduling cycles as much as it's appropriate for high volume execution needs. Also you should consider running processes with concurrency using threading in the scheduler, or use asynchronous approaches for better task handling in high throughput.  You should be aware that each job can cause substantial load in ` CPU `. If a `JSON parser` runs very high, it should use the optimized library, if you have very specific requirements or use-cases. The system also can utilize cache in JSON to increase scheduling speed for large JSON definitions

The best optimization practices involve profiling execution to determine performance hot spots, for optimization: `profile python ` can help with profiling, for the best possible throughput with low load. Knowing where performance needs improving allows you for focused optimization. Consider also running on optimized machines if you expect a substantial scheduled job loads. 

## Security Considerations

When using credential based configuration you must secure the configurations from access by any outside sources, since those are credentials and keys

Input Validation plays a key consideration and is necessary. Validate that `jsonPath`, `tasks, configuration files are properly configured, to protect any unauthorized modifications`. Ensure file paths and permissions have correct configurations so the ` STS `, cannot have malicious or corrupted access .

For production, consider setting proper system user access, with access restricted to a minimal role with only `access STS,` and its `configurations files`. For any external connections to the scheduled tasks. Use encrypted channels to send the task executions and data/ credentials.

## Roadmap

Currently the development aims for: Improved scheduling policies. A GUI for easier job scheduling . An integration in external task monitoring system

Version: 0.1, with JSON and core features implemented

V0;2. Task error notification

Future features in planning include `API `. to expose and enhance integration capabilities .

## FAQ (Frequently Asked Questions)

*Can the configuration use variable expansion in its paths ?*
Currently it does not and requires hard paths or a more complicated expansion according requirements to the configuration which might affect scheduling in some environments as may not exist. It may need custom extensions for expansion requirements for paths as it can drastically scale and change environment parameters, but that would impact complexity
`Does this support database- backed configurations? * The framework uses configuration files instead
 `* What happens during job execution failure. Is this automatically repeated. STS` logs execution failure. The scheduler restarts as needed, without a specific repeat schedule and is designed for idempotent scripts for execution, where repeat executions should provide same outcomes. 

## Citation

We thank our contributors in their time invested to this `STS`: The framework provides open standard implementations that can benefit a multitude other applications that have requirements of job executions
If this work assists in academic- or related work:
@article { SimpleTaskScheduler ,
     author = {Contributors},
     title = {Simple Task Scheduler},
     journal = {GitHub Repository},
     year = {2024},
     url = {https://github.com/your-username/sts}
}

## Contact

We invite anyone wanting more assistance or support through Github Issue reporter, for more direct help:

Email : example email@test,
Discord channels: Link discord.com channel to join and receive community feedback: We aim at making scheduling accessible with simple implementation with this task-driven project