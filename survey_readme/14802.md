# Simple Task Scheduler (STS) - A Python Task Execution Framework

##Description 
STS aims to simplify and automate task execution in projects requiring periodic or timed jobs. This project provides a lightweight, customizable framework for scheduling and running various scripts, functions, or processes. It supports various scheduling triggers like interval- based, cron-expressions and manual invocation providing flexibility.

STS is built using Python and leverages `asyncio` for efficient execution. It is designed to be modular and extensible allowing users to easily integrate different task types and scheduling strategies. This framework is ideal for developers who seek a straightforward method to incorporate job management in their applications, eliminating the need for complex external services.

Key features of STS encompass a task registry, scheduling mechanisms and robust retry logic. The registry provides a centralized storage system for managing tasks. Furthermore, its retry capabilities ensures resilience against temporary errors and intermittent connectivity challenges.

STS minimizes resource impact by using an event loop, and it is optimized for low- latency scheduling while providing clear logs. It supports custom tasks written in Python or can be easily extended to handle external executable files or commands.

This scheduler can also be easily integrated into various projects - from data ingestion pipelines to system monitoring. The design prioritizes easy usage for both beginner and advanced programmers. STS is a tool designed to improve project efficiency. 

## Installation Instructions

Before proceeding, you' ll require a Python 3.7 or greater.  It can be checked by typing `python3 --version` at the command prompt.

STS depends on the asynchronous programming environment in built in Python which means no explicit installation. It relies upon asyncio, a native module of Python 3.

First, create a virtual environment to isolate project dependencies. This command creates a new directory "venv" in your current directory and initializes the environment. `python3 -m venv venv`

Next, navigate into the newly created environment. The command `source venv/bin /activate` is used on Unix based system (macOS/ Linux) to activate the created virtual environment. For the Windows, run `venv\Scripts\activate `

Now the installation of STS can be done using pip.  The command `pip installer sts --upgrade ` will install and upgrade STS to the latest available version. It is highly encouraged to use `--upgrade`

STS relies solely on Python and does not demand the usage of any specific external packages beyond those built into the standard library.

Finally, ensure your system has write permissions to the environment to properly write the STS libraries and their requirements. Check that you're using a user-friendly editor or IDE to easily modify and execute Python code. 

## Usage Instructions

To start, you need to import the `Task Scheduler` and `Task` classes from the `sts` module. In a Python file, write: ` import sts `

Create a task by subclass from the base `Task` class. You can define a method called `run`, which is the method that will be automatically called when the task is triggered.  Example: ` class ExampleTask(sts.Task): async def run(self ): print("Running example task")`

Add the task to the scheduler using the `add_task` method.  Example: ` scheduler =  sts.Task Scheduler(); task = ExampleTask(); scheduler.add_task(task)`

Run the scheduler indefinitely with the ` run` method. This will start the scheduler and execute tasks according to their scheduled triggers. Example: ` scheduler.run()` which will start the scheduling loop.

You can also schedule a task to run at a fixed time interval using the `schedule at` method. `scheduler. schedule_at(task, "10s")` will cause the task to run every ten seconds. This offers flexibility when timing is critical for task completion.

For more advanced use, explore cron expression scheduling with `schedule_cron`. For instance, `scheduler.schedule_cron(task, "0 0 * * *")` will trigger the task every day at midnight. 
   
The STS framework is fully asynchronous. The `run` method blocks execution until the scheduler is stopped. This behavior can be modified by setting the `blocking` parameter during instantiation to false.

## Configuration

STS relies on environment variables to configure its behavior. The `LOG_LEVEL` environment variable controls the verbosity of the logging output. It can be set to 'DEBUG', 'INFO', ' WARNING', 'ERROR', or 'CRITICAL'.

By default, STS runs in a blocking fashion. To change this behavior, you can use the `blocking` environment variable set to true which allows running a background thread that does not stop. Setting other environmental parameters needs further modification of core functions which might introduce unwanted side-effects. 

To change logging settings beyond the general `LOG_LEVEL` the custom implementation needs the use of standard libraries such as the "logging" library from Python.  This enables customization such as adding multiple output locations for log messages and setting formatting patterns.

You can also customize logging behavior with a file ` config.ini ` that overrides defaults for all parameters related to output streams or formatting, or log locations, allowing the system a smaller footprint and a centralized configuration approach. This can further extend functionality by adding parameters and logging handlers based on your own use-case

For complex environments where external configuration managers are necessary the STS library will provide support. A custom handler class for retrieving environment configuration from sources such as etcd or Kubernetes Secrets needs further implementation guidelines in later version release, offering a more adaptable architecture.

To manage secrets and prevent their storage in plain text configuration files the ` secrets_store ` configuration allows specific environment values and secrets locations. This ensures that security practices for configuration values will follow industry accepted practices such as Vaults, or similar solutions

To configure scheduling the default values will work for a vast amount of situations where custom and dynamic settings are unnecessary but to configure custom scheduling, an API is provided where you must provide scheduling logic based on `datetime` which gives greater control and prevents potential configuration error from invalid inputs and ensures scheduling accuracy

## Project Structure

The repository contains the following structure:

```
sts/
 |-- src/
 |   `-- sts/          # Main STS package
 |       `-- __init__.py # Initializing for STS
 |       `-- task_scheduler.py   # Implementation of the TaskScheduler
 |       `-- task.py          # Implementation of Task Class
 |       `-- utils.py         # Various helpers functions
 |-- tests/       # Directory with automated test files for the STS implementation
 |   `-- test_task_scheduler.py
 |   `-- test_task.py
 |-- docs/
 |    `-- index.md # Project Overview, setup and configuration files documentation
 |-- README.md # You are currently reading it
```

The `src/sts` directory holds all source code.   It encapsulates all STS components like scheduling, task creation, management.

The `tests` directory consists of a variety of automated test functions to test and check functionality for various configurations of `Task`s. This enables a quick verification if core changes are implemented

The `docs` folder provides an easy reference point. All setup, configuration details for all documentation, tutorials and best practices can be easily located and read within

## Contributing

Contributions are welcome and encouraged. Feel free to submit pull requests and issue reports on GitHub. All changes go through thorough peer reviews before they are merged to avoid any breaking behavior to any core features and ensure all functionalities operate in a robust way.

First, clone the repository. After creating your branch using command line such as `git checkout -b < new branch >` start with implementing or modifying functionality, make sure it follows PEP 8 standards with code- formatting using black, to provide uniformity in styling to maintain project clarity.

When developing the implementation or any code modification run unit test and create tests if necessary with pytest or a testing module such as pytest to confirm proper operation. The automated test suite is crucial to guarantee project robustness as it prioritizes code stability over functionality and security,

Ensure proper code style and quality. Before creating any changes, run all lint checks by creating and installing all precommit checks to confirm all the coding style guides set contain.

After testing and verifying changes, push branch into github by following instructions such as:  `git push origin  new branch`  After this is performed and submitted create the appropriate merge and provide a concise but detailed message on functionality changes to assist peer review, so it is easier to grasp any potential implications on the main project component 

## License

STS is licensed under the MIT License. By using, contributing to, or modifying this project, you agree to be bound by the terms of the MIT License, granting permissive rights with restrictions to usage within legal bounds of software license and compliance. This enables users to freely employ STS without restrictions on its redistribution

## Acknowledgments

We extend our sincere gratitude to the asynchronous Python community and all open-source libraries which inspired STS design. Specifically, libraries such as asyncio which provide essential features and functionality that make task execution streamlined

This includes all Python documentation, online communities for guidance to resolve implementation details as we progressed with developing the scheduling task implementation which allowed to build STS in efficient manners without significant roadblocks in functionality or stability. 

Thanks go to all contributors that provide feedback.

## System Architecture

The system operates through the asynchronous TaskScheduler which utilizes `asyncio`. TaskScheduler keeps track of and manages the lifecycle and manage the scheduled Task, executing at specific trigger. A registry keeps task instances available in order of creation for quick access in trace and analysis operations. 

Tasks are instances created of the defined `Task` class inheriting all properties that allow it to operate within its scheduling context such as run-method and parameters passed through when instantiated in `Scheduler`. 

Tasks themselves run using coroutines. The core functionality utilizes ` asyncio.sleep ` calls that enables it for a more flexible and accurate schedule-time operation without using threads or blocking operations. Tasks run asynchronously which means multiple scheduled functions are not blocking other automated scheduled functions. 

Data Flow involves Task instantiation with parameters from Scheduler which triggers an async coroutine ` run-method`, and finally it completes execution which is then tracked within its lifecycle in the Scheduler to manage its operations, status updates or any failure events during runtime which it reports in system output 

## API Reference

*   **TaskScheduler:** Main scheduler class.
    *   `add_task(task)`: Adds a task to the scheduler.
    *   `remove_task(task)`: Removes a task from the scheduler.
    *   `run()`: Starts the scheduler loop.

*   **Task:** Base class for tasks.
    *   `run()`: The function that performs the actual work.  Subclasses implement this.

*  **`sts.utils`**: Helper Functions to perform utility related operations like checking dependencies or setting performance optimization

## Testing

To run tests use: ` pytest`. This uses `pytest`, and tests must include a test_ prefix

You should first install any needed testing frameworks, such resources or mocks if any dependencies are missing, to create isolated environment with test configurations and settings for a quick, efficient automated unit tests and testing process and a test setup with mock objects

It will search all `test*.py` and `<module_ name> _test.py` file locations to identify all testing scenarios. All functions will execute within pytest. This allows us an efficient way of running our testing functions and identify bugs early to prevent regression on future functionalities 

## Troubleshooting

If your tasks aren&#x27;t executing: double-check your schedule settings. In particular review any cron syntax mistakes in the configuration file which might result the scheduled time being inconsistent. Also ensure environment has appropriate read access to execute and access any dependencies required during operations and verify scheduler instance has correct configuration values for any dependencies. 

Check logs, verify all the configuration files or logging parameters such that logging statements output appropriate errors or trace logs and review system errors that are causing task termination to determine and solve any underlying issue

## Performance and Optimization

Optimize your Task implementation code and be wary to implement any time-sensitive functions to improve efficiency for task executions.  Implement any external library optimizations or hardware capabilities for high performance operations to minimize resource overhead to reduce processing costs and latency of scheduling functions .  For frequent scheduling tasks cache and reduce the utilization rate

Utilize `asyncio.sleep` calls and reduce thread blocking by employing `select.epoll`, `select.poll` and or using event based architectures for faster operations which are ideal when handling large scale of concurrent processes to optimize and enhance task scheduling capabilities to minimize system latency. Cache any data frequently retrieved during runtime.
## Security Considerations

Protect all configurations against unauthorized changes with read only or access permissions with proper role separation in the environment for production settings which reduces the likelihood malicious attacks from unauthorized external users that are exploiting access points, such that access controls should prevent unauthorized access of any configuration

Secure credentials such as API keys passwords with environment values that have appropriate secure storage mechanisms like vaults. Sanitize any task related arguments and data and ensure inputs are validated for security.  Regular patching for STS, including the core implementation with all available patches and dependencies that have vulnerabilities and security exploits 

## Roadmap

*   Add more task types: email tasks, external command task and webhook tasks implementation to enable flexible use and extend capabilities.
*   Add support for different message queues like RabbitMQ to allow distributed processing and scale out
*   Develop an improved GUI or improved dashboard which allows visual representation scheduling configurations for monitoring purposes with ease, enabling operational teams better management tools

## FAQ (Frequently Asked Questions)

Why are tasks not executing in the specified order. Ensure all scheduled triggers don not coincide. Review the implementation for race condition and check all configuration variables and task settings

Why are some errors thrown in task run. The exception needs careful analysis with detailed traceback and debugging instructions which needs logging parameters or configurations and also ensure dependencies and configurations have access permissions for task runtime 

Does `STS` work within cloud-hosted environment like Kubernetes, or container platforms with dynamic environment configuration to scale and provide automation

## Citation

Please cite the STS project as follows:

```bibtex
@software{SimpleTaskScheduler,
  author = {Your Name},
  title = {Simple Task Scheduler},
  year = {2024},
  url = {https://github.com/yourusername/sts}
}
```
For proper acknowledgement ensure to link and give appropriate publishing and contribution to ensure project attribution
## Contact

For inquiries, report errors or to propose enhancements, use email address ` support@simpletaskscheduler.example ` or

Contact community group at ` community @ github dot com ` to receive feedback on features that are desired for further project updates 

For additional information visit the repository page to report all information that would benefit future project updates