# StellarMapper - An Autonomous Celestial Mapping Platform 

## Description

Welcome to Stellar- Mapper a robust, cross- platform celestial mapping and exploration application.  StellarMapper allows both researchers and recreational star- watchers the capacity to automatically map constellations from image inputs or simulated sky conditions in an open, expandable architecture. The system uses sophisticated machine- learning based image recognition techniques to determine celestial body identification and placement relative to the local coordinates, creating a 1:1 map.

Our architecture is modular. Core components like the image input parser is decoupled and replaceable, allowing new formats to be added simply with minor modifications to supporting components. We employ asynchronous data pipelines using Python to allow quicker processing of the high resolution imaging and data processing steps involved in automated celestial body detection. The result provides users an unparalleled level of accuracy and flexibility to suit their particular research.

This software tackles many existing limitations found within existing astronomy- oriented image recognition tools, by implementing real, time image- analysis and automated star identification techniques, enabling faster analysis compared other manual or partially auto analysis tools found across research fields in astrophysics. The open architecture facilitates rapid research prototyping, and data analysis for researchers in many scientific subfields.

Stellar Mapper's intelligent system learns new celestial objects, increasing overall system efficacy through a self correcting, iterative approach which allows continuous improvement to system recognition, classification and placement accuracy of celestial body locations. The modular architecture supports integration into larger research networks via REST or message queue, enabling the platform as a key data analysis point across many scientific fields requiring high fidelity spatial mapping.

Finally, user customization is also prioritized with flexible rendering options, allowing users the capacity to customize rendering to specific telescope systems, research goals or visual styles to enhance usability and data interpretability to suit various research objectives and visual preferences. The user experience and interface is highly configurable, and designed to scale in complexity and feature set to suit a user from the amateur enthusiast to a dedicated expert user.



## Installation Instructions

The initial steps will be environment preparation and Python dependency management, followed by a configuration phase to suit the end user hardware and operational environment. This section details the full installation steps and platform considerations.

Before we proceed, it is critical users ensure they fulfill the core prerequistes of this package including: python3.7 or newer installed (version management using tools like Anaconda and venv is recommended for isolating project dependencies from other systems), as we use features only introduced within newer version ranges of Python, and an operational, up to date, package installer (PIP or similar package managers). 

Next, we're creating virtual environments to contain our dependencies to avoid conflicts with existing systems is strongly advocated as an isolation practice within the field.  Using your terminal (Linux or macOS), you will type: 
```
python3.  {your environment name here}.create
cd {environment_name}
source  /bin/activate
  # For Windows, activate using the relevant activation command within your virtual environments management utility, Anaconda etc.
``` 
Now the user must use `git` or `svn`:

```git clone {Repository URL here }```
The next step after obtaining our base installation files and code is using package installers (pip/conda) to install dependencies, as follows, and note if any packages required are unavailable on your current system:

  ```pip install numpy scikit  learn pytorch torchvision pandas  astroplan matplotlib requests Pillow
``` 

Note: If using CUDA on the host hardware for enhanced acceleration for image processing operations and neural processing networks, then additional configuration steps for CUDA driver compatibility and library versions will apply.  Documentation detailing CUDA configurations and compatibility is provided elsewhere as supplemental information.  
On Windows, please consult the official Python documentation for details. 
The system is now setup, with a base installation ready and configured to run!

The project uses YAML files for storing system configuration. These files need specific locations and formatting to run correctly. Ensure `configs directory` contains `mapping_configuration. yaml ` with proper parameters.

Finally ensure you' have installed necessary system packages (if applicable to image input or processing hardware), like image processing codecs or hardware drivers required by image acquisition or intermediate image processing libraries to run correctly. 



## Usage Instructions 

Once installed you have to run this software using the `main.py script`. The software is command- line and API accessible with options detailed below. This will begin image processing from specified input source or start an internal simulator and generate an interactive celestial map. 

First to run the image processing mode:  ```python3 ./app main, with the --input_ file <file_path to the image.  .jpg format recommended>.
```  Subsequently you must also set the coordinate system using ` -- coordinate <coordinate reference frame> with the options being:  equitorial, galactic or horizon .
 
The API endpoint runs via an integrated server. To activate the REST interface, execute the file with ` --api`.  Subsequently use your HTTP request library of preference (Curl, Rest-Client)

Example REST request (get latest map): ```Curl http //localhost:808  map ```
 
The default rendering system uses the built-in matplotlib library and provides an interactive window. The output is saved by adding a `--output < file location >.  .svg format preferred > argument at the launch command. 

The simulator runs with the command `./app -- sim -- resolution 2048  - - duration 6 hours` and provides an interactive celestial map, simulating a sky- view for the given parameters to aid user research and training in the tool itself . 

Advanced configurations include automated data capture, where an attached imaging unit will automatically capture, map, process and save results, using system timers and automated processes to minimize human involvement with data capture and processing. This is enabled using the `-- automated_ capture` command argument when launching.



## Configuration

The StellarMapper configuration is centered within YAML files located within  `./configs` directory.  These configuration files govern core functions within both runtime and data processing pipelines, from image acquisition parameters to mapping and visualization options. This ensures ease of configuration and customization of core functions without code edits.

The core mapping configuration parameters within `mapping_Configuration YAML` define the resolution of mapping, coordinate system, and rendering parameters to enhance system efficiency and output accuracy for different user scenarios. Users need to configure system hardware specifics in `system. yaml` to suit end device specifics, like memory and image processing acceleration capabilities.

Environmental Variable control also provides runtime configuration. `STM_IMAGE_SOURCE  specifies`  the input source to use. If unset defaults to a simulated sky. The `STM DEBUG ` variable allows debugging mode with extra logs output and increased verbosity of system events. This is a crucial configuration option during development.

Custom parameters for rendering styles (color maps used and display scaling) is enabled through a JSON file named `display_config. json`, which provides granular level display settings to customize how celestial object data are represented to users.

Furthermore custom mapping models (image recognition and processing pipelines) and associated models (trained neural networks) are specified to be run with custom model configuration files. Each new model requires specific model config file for integration within core system, with detailed information about model parameters specified, like learning speed during processing and classification accuracy metrics.

The system offers the option of dynamically configuring data output locations through an external service that is specified through system configurations and the user must provide appropriate credentials. Data storage location is a configurable system component allowing flexible options. This configuration is critical for scaling to larger systems that need distributed, external access to the mapping results. 

System resource limits can and should be defined through the config system too, to allow efficient resource allocation and usage within multi-user, distributed, system environments for improved throughput and responsiveness. 



 ## Project Structure 

The overall repository contains several directories each designed as functional component and containing specific functions or code for StellarMapper.  The structure below is an outline.

```
StellarMapper/  (top  level directory )
  - app / (Main script to start program, contains the CLI parser logic)

 - configs / (Contains various configuration files in  .  yaml . and .json format to specify various configuration parameters )
 - datasets  / (Pre- trained models to support image recognition and object classification for various celestial objects)
 - docs  / (Contains documentation and supplemental data)

  - src / (Core code, broken down modules for image processing algorithms , celestial body identification routines, coordinate calculations and data visualizations)

  - tests / (Unit and integration tests for the core system and modules)
```

  ` src `/ is further partitioned into modules: `image_parsers `/ contains code for different image file type parsing (JPG PNG, and TIFF),  `mapping_algorithms`/ houses core image recognition and object classification and spatial coordinate algorithms and `data_ visualizations`/ manages the display of maps and data. This separation enhances readability, scalability and maintain ability, and modularity, and code reusabiliity. `tests/` directory includes test cases for all components in `src/`. 


## Contributing 

We value contributions that expand Stellar Mapper functionality, fix issues encountered, and improve system documentation. Contributions follow specific procedures that promote maintain able and standardized code and testing procedures within the codebase. 

Report issues using the project's issue tracker on GitHub (provide detailed steps and screenshots or relevant information), allowing developers quickly reproduce and address issues in a collaborative approach to bug- fixing efforts and system maintenance. 

Submit code fixes and improvements as PRs, ensuring the included test cases cover changes made in code, to maintain quality and ensure no new regressions are introduced with new modifications, or features.

Adhere to coding standards and guidelines, documented in `./ docs `/ `coding_standards md `. These include consistent indenting, descriptive variable namings, and detailed comments where applicable. Code review processes are conducted prior to code merges, which will ensure all contributions follow best development practices.  




## License

This software is distributed under the MIT License (https://opensource.org/licenses/MIT). 

By using StellarMapper,  you are granted the freedom to distribute and use the code as you see fit including commercial usage. This also entails an implicit acknowledgement and agreement that no warranties, either explicit nor implicit, come with Stellar Mapper. 



## Acknowledgments

StellarMapper's development was deeply impacted through many contributors in open sources and scientific fields and is thankful for these contributors to our development effort as follows: 

-  Astro Plan (https://astroplan.readthedocs.io/en/stable /) for celestial mechanics computations used for automated sky simulations.
-  The Scikit- Learn machine learning community, which provides core image processing algorithms for object identification and mapping. This library is critical towards object location determination and classification within mapping.
-  NumPy for numerical computations within the mapping and simulation pipelines. 

We extend special acknowledgments to [Contributor Names or Research Groups here], who contributed code modules, and provided feedback, enabling a robust platform for automated star tracking and research data generation. This includes contributions around hardware optimization, data acquisition, system testing, and API design that greatly expanded this system.

## System Architecture 

StellarMapper's overall system architecture follows a modular pattern. This enables easy extensibility, scalability and maintenance, separating functions into discrete modules and components with defined interfaces. 

The core is the `app`, containing a CLI parser module handling commands and arguments that triggers a core event loop which dispatches to appropriate modules for processing or simulation. `image parsing` module reads, decodes and preprocesses incoming image inputs from different camera formats. 

The `mapping engine`, the central processing logic, leverages machine learning algorithms implemented with `Scikit-Learn` for celestial body recognition, identification, and spatial mapping. It outputs a set of identified celestial objects and their spatial positions.  

Next is the display module that renders the mapped data and creates interactive visualizations of the celestial map using `Matplotlib`. This includes the API server module which exposes endpoints for accessing mapping data programatically, facilitating system integrations. This allows other research or operational pipelines to leverage Stellar- Mapper for spatial data analysis.

The asynchronous design using Python threads, and asynchronous data structures allows efficient resource handling and scaling across multi-core hardware.




##  API Reference 

The StellarMapper API exposes functionality through a REST interface. 

**Base URL: `http: //localhost: 808 `** (Default)

**1  / map**

* Description: Returns the current celestial map
* Method: `GET  Request`.
  Returns the map in JSON format, providing a list of celestial objects and their locations, in the equitorial frame. Example: `{ "celestial_bodies":  [{"object_name": "Sirius", "ra": 6h45m08. .9s, "dec":"-16 42 58. .1"}, {"object Name": "Betelgeuse", "ra":5 h51m14. .5", dec ": +7.0"}]  }`.
* Parameters: None.

**2  / configuration** 

  *Description: Returns all active configurations for StellarMapper
  *Method:: GET
  Returns the configuration in JSON format, including the system hardware specifications, image processing parameters and rendering styles.
* Parameters None
**3 / simulate  (Advanced)** 
* Description : Triggers an interactive simulation with given parameters.
  Returns JSON with configuration parameters.
* Method: POST request
 * Parameters `resolution` (int) ,` duration `(int), `coordinate_ system`. 

  Note: Authentication is not supported. 

## Testing 

The software incorporates extensive testing procedures across various levels to provide assurance in code reliability and performance. 

Unit tests are implemented using `P yt est`, and cover individual functions within various packages,.  Each function with non- trivial business logic features at least 2 tests with both pass- cases and corner conditions covered in automated procedures, as part of continuous code quality maintenance.  
The integration tests ensure various functional areas are properly inter-linked within modules and that they operate according with expected behaviors, and cover core functionality and inter component communications within the Stellar Mapper environment .   

 To initiate testing simply call, ```python -m pyt  test ./ tests  `.
  A `Dockerfile` for running integration tests and end- to -end scenarios using automated pipelines.  
   This facilitates reproducible build environment to allow reliable automated and standardized testing environments across platforms for quality testing assurance procedures . 

## Troubleshooting

Here we detail the common error states observed during installation and final run configurations to provide guidance with common problems:

Issue: ` Module Not foundError: numpy`, or other similar error during initial install. This is caused when required system-access packages and or system library components cannot locate Python-required packages during the setup stage.
* Resolution: Verify your `PYTHON` Environment Variable loads your virtual environment properly, re install packages and ensure the installation path does align and load properly from virtual system, check package manager and Python interpreter version consistency across system environment..
Issue: Inability to read `Image Format Error`, typically caused with incompatible codecs on system hardware. 
Resolution Verify that all codec drivers and supporting image codecs and file parsers for different format file- types have the appropriate drivers to ensure image- decoding is functional on your end host systems

## Performance and Optimization

Optimizations can increase performance significantly through customization configurations: 

- Use high resolution GPUs if doing real time imaging to take full benefits for parallel processing for improved data rates.
- Cache computed mappings to reduce recalculation time if frequently used
- Profile system with appropriate performance measurement frameworks and optimize data structures, image handling algorithms as identified through profiling, which identifies potential bottleneck and resource limitations

## Security Considerations

Securing a celestial map software requires attention, particularly when connecting hardware to the internet, with appropriate authentication, validation.
 -  Avoid running software with administrative privileges
 - Ensure image data received comes from verified data input and prevent code/ data corruption with integrity measures such as hash values and checksum validation.  



## Roadmap

Planned feature sets and improvements over StellarMapper in sprint development: 

* Integration with astronomical data repositories such as SIMBAD, or other publicly sourced astronomy catalogues to enrich data with further object- specific information . 
* Automated object catalog generation, providing user ability to generate and export custom star catalogues and data- related reports based around their mapped images and research
 * Advanced data visualization and custom chart plotting with enhanced user customizable styles, for specific visual research and presentation styles

## FAQ

**Q: StellarMapper works after running install but gives errors?**
  A:  This often results due missing environment-specific packages such libraries that were deployed and are used during installation, so re install using proper installation guides to correct any configuration problems that might prevent it from properly operating 



## Citation 

Proper Citation is essential to promote proper use within a research setting, please cite: [Author Name or Research Group ] StellarMapper, An Autonomous Celestial Mapping Platform  . [Repository Address or Journal Name if Available ]  .
 BibTeX format
 @software{stellarmapper,
    author = {StellarMapper Devs },
  publisher = {GitHub},
    url = {[repository link]
  }

## Contact

For bug reports, general queries or contributions send mail with details of the situation with the title reporting StellarMapper issues: 
`contact  [email] ` and include relevant attachments for assistance and debugging assistance 
For further information, please refer the Github repository to follow ongoing development discussions .