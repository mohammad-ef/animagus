# Distributed Key-Value Database - "Krita"

This is a README documentation for the Krita project. Krita is a decentralized, horizontally scalable key-value database built to be resilient, performant and simple to use and integrate. Designed around a peer-to-peer ( P2P) architecture, Krita aims to offer reliable data storage across a distributed node network, providing a robust platform for applications requiring data durability and availability in a dynamic or uncertain infrastructure.

Kritaâ€™s core philosophy is "eventual consistency" with a focus on strong conflict resolution mechanisms, enabling applications to tolerate temporary discrepancies while guaranteeing data convergence over time. We have leveraged concepts found successful in distributed ledger technology, like Merkle trees, for efficient and tamper-proof validation of the data. This makes it a useful tool for blockchain applications, decentralized storage, or any system requiring a robust, distributed data layer.

Krita supports standard KV operations: get, put , delete, and supports range queries to allow for efficient data retrieval. The underlying P2P topology is dynamic, with nodes discovering each other and adapting to node joining and leaving. The data is replicated across multiple nodes to increase both availability and data durability. Our goal is to provide a foundation for developers to build reliable and scalable applications, leveraging the advantages of distributed systems.

## 1 Installation Instructions

Before installing, make sure you have a working Go ( >=1.20 ) environment. Krita is written in Go, utilizing its inherent concurrency and cross-platform compilation capabilities. This ensures a smooth and efficient deployment across a multitude of operating systems and environments.. 

The simplest approach is to download the pre-compiled binary from releases or build it from source. The binary can be downloaded by navigating to our project's release page, and choosing the appropriate version of the binary for your system. This is the recommended approach, as it reduces the build time.

Next, you' ll want to set up a directory for the Krita configuration files (e.g., `/etc/krita`).  This directory will hold node configuration, peer lists, and other essential settings for the database's operations. Creating it ensures your data is properly structured and isolated from the codebase.

Then, to compile Krita from source, you can use the `go build` command. You should execute `go build .` within the Krita repository directory to initiate the compilation process, generating an executable for your specific operating system and architecture. 

On Linux and macOS, you might encounter permissions issues, requiring you to execute the compilation with sudo `sudo go build .`. Ensure proper file ownership and permissions on configuration directories, using `chown -R your_user:your_group /etc/krita` for secure operations.

Once you built it, install it by placing the resulting binary within a standard system binary directory (e.g., `/usr/local/bin`) so that it will be accessible to the OS, making execution more effortless. This simplifies running Krita across multiple locations in the terminal, streamlining its utilization.

On Windows, the Go installation typically places the build executables within the `$GOPATH/bin` directory by default. Add this directory to your PATH environmental variable if the build is successful to execute from command line.. You might also choose another directory to store executables for convenient accessibility and manageability..

For proper functioning, it's critical to update system environmental variables to include the build binaries. Specifically add `$GOPATH/bin` (Linux, macOS), or  `%GOPATH%\bin` (Windows) into system PATH environment, this step simplifies execution in a variety of locations and configurations. This ensures proper recognition by shell environments facilitating effortless access

Finally, download all the required Go modules.  Use this command to fetch these requirements, ensuring all dependencies exist within the workspace. The execution will automatically install them from a centralized version control system and place all files necessary.   The command used would be `go mod download`. 

## 2 Usage Instructions

Starting a Krita node involves executing the Krita binary with configuration arguments or a configuration file specifying settings such as node ID, listen address, peer list, and storage directory. Running simply, the `krita` command with nothing should be the basic default. 

You can initiate a node and have it listen on a specific port using the command: `krita --port 8080`. It can discover new peers by defining their IP address using the `--peer-list` argument such as: `krita --port 8080 --peer-list peer1:8081,peer2:8082`. You can also point it towards a custom directory: `krita --port 8080 --data-dir /data`.

Once multiple nodes are running, they can begin transferring and validating KV stores with data using command `put key value`. A run-query `get key` can return stored KV pairs and ranges, while deletion operations with command `delete key` should also work, removing stored keys across network..

For complex automated operations, it supports gRPC and HTTP interfaces and supports integration of clients and servers. A full set of example scripts using gRCP, as well as command line tools for simple queries are within examples folders.  Refer to them as templates. 

To view node metrics for resource utilization and database operation, expose prometheus endpoints, and utilize them via Grafana. Krita offers extensive instrumentation capabilities through the exposed prometheus metric and can integrate with a number of visualization tools to provide a dashboard with performance overview

Emission errors when querying may indicate connectivity problems with other Krita node or an incorrect KV storage on one particular instance, it's worth reattempting after the initial connection has reestablished..  

When interacting using gRPC or APIs, the format should strictly adhere to schema for consistent and predictable usage of KV store operations. Incorrect schema can lead to errors, requiring developers to review their request payload against specification for smooth functioning.  

For basic testing, use built-in utilities or sample programs, allowing quick evaluation and verification for correct behavior before deployment in actual systems. These test setups ensure Krita performs under different scenarios..  

Finally, you must check node synchronization, making sure all KV operations reflect changes across a Krita peer-to-peer system for data convergence over a network with eventual consistency behavior and proper propagation between all Krita peers.  

## 3 Configuration

Krita primarily leverages configuration files for managing operational attributes, and environmental parameters offer alternative mechanisms. It supports JSON for config settings as default to allow flexible management and easier editing. It is possible for users to change configuration via flags.

Krita reads a configuration file by default located at `/etc/krita/krita.json` and if file does not exist or invalid settings provided on flag then default settings will come to effect and be loaded. It supports both global system parameters via flags at start and specific local settings in file which takes effect if it does not collide.

The `krita.json` config allows customization with the ability to specify peer nodes and their addresses, the default port on which Krita node can listens. The default is set as 8080 which can override using configuration parameters and is otherwise set using a configuration flag on runtime, allowing flexible and rapid operational adjustment

For secure operations and data integrity validation of nodes during peer interactions, it provides mechanisms like TLS, supporting both mutual authentication with X 509 Certificates with validation.  Config settings for TLS such as Certificate location are within file as optional.   Proper certificates configuration enhances system robustness in distributed deployments and secures the communication between the different node components

You must carefully set appropriate values to prevent potential conflicts during peer connections. Setting `cluster ID ` as distinct and different for various instances can resolve this issues to prevent network errors due conflicting network topologies between databases and peers . Proper configurations ensure proper node discovery across different deployments, facilitating robust data propagation among Krita instances

Krita allows dynamic peer-node additions via an internal peer-manager and RSS protocol discovery. It supports auto scaling capabilities and enables easy management of distributed database across dynamic deployments. Proper node-to-node connection enables data availability and consistency in dynamic network environment where peers come. 

To fine tune resource allocations of individual database nodes you are welcome to set up custom limits and caps. Memory management can happen in two forms either global memory caps to avoid OOM scenarios. Additionally, Krita exposes thread management settings, and CPU allocation allowing users manage the overall operation on resource utilization and optimization..

To improve security you can enable Auditing of all the database access. The configuration can set what events get audited with the option for storing those audits. These are crucial for monitoring security compliance in a production setting, which will enhance the situation and protect the data against security breach. 

Finally to avoid errors or performance degradations set custom garbage collection settings, and cache configurations, allowing optimization with different application load characteristics by controlling cache-related configurations to optimize overall efficiency, enhancing throughput and preventing bottlenecks under various circumstances.

## 4 Project Structure

The Krita repository maintains the structure with modularized codebase promoting clear design principles as part of its operation for scalability. Each folder serves a specialized objective with dedicated functionalities in Krita, and they're listed and described below:

`cmd/`:  Contains all CLI applications. The main program for initiating nodes are in this path including `krita` and its corresponding entry point logic. This structure helps with ease and management, keeping all entry level operations centralized

`internal/`: Holds implementation specific modules for data structure validation as a foundation, network protocols with P2P logic as foundation as the base, core algorithms that power distributed operations as foundation of this framework, making core data access efficient with database interactions..   Accessing and using the contents from `internal` restricted outside, ensuring data integrity

`pkg/`: Contains libraries and common utilities shared with various subcomponents of database operations that can used and accessed across multiple components as needed with reusable functions to minimize redundant code, increasing project development pace while enhancing code maintainability

`configs/`:  This repository directory provides examples as template and reference to customize and setup under different use scenarios and configuration parameters, enabling rapid deployments

`protos/`: Holds protobuf definitions describing APIs for interaction via HTTP and GRPC with data formats that facilitate inter process interaction across multiple languages with a structured manner. All APIs adhere the definition and schema, facilitating cross platform integration and compatibility .

`tests/`: Hosts the unit integration when the end-to end scenarios of various components with validation to check and confirm expected operations across different usecases for ensuring quality standard.

`scripts/`: Houses helper and automated build as well deploy tooling and tasks and utility tools.  Automation enables streamlined build, release, management with a simple interface, facilitating developer workflow for efficiency

`README.md`: Project document providing documentation of all functionalities with usage and instructions as the foundation for the database for accessibility

`Makefile`: Used with build process, automating the compiling the source and building executable files for the Krita framework.   Build and management of build files

## 5 Contributing

The success of Krita rests with all contributors with community-focused efforts for expanding capabilities to ensure Krita thrives within the community of its usage

Report Issues and provide suggestions for improvement and new functionality with issue tracking in the issue page with detailed providing of steps for reproducible issues that helps to identify bugs

Pull requests with changes must include a descriptive summary for each proposed contribution for easy and efficient peer code reviewing by others for understanding. The code should conform the coding standard to enhance overall codebase consistency across various projects, improving project maintainability and understanding across various contributions

Adhering the Project code standards, ensuring proper linting style guide. The use with Go format to enforce consistent and uniform format to increase clarity across all projects for better project management and code readability and overall understanding

Test driven Development practices are encouraged allowing all code contribution, ensuring thorough verification to prevent errors during implementation for increased quality assurance. Test coverage ensures stability for various implementations with built integration with testing standards for robust implementation and assurance 

Follow a consistent and standardized coding format as part the community guidelines, contributing to shared project goals while increasing collaboration. Consistent adherence to these code style ensures maintainability, improving team workflow and collaboration efficiency 

Code must include tests before submitting to the system with comprehensive documentation with inline commentary, explaining complex operations within source to enable easy comprehension

## 6 License

Krita is licensed under the MIT License with a permissive model to use the database under certain usage constraints. You are welcome and can distribute the Krita framework under the license, with ability modify or adapt it with proper licensing, enhancing freedom to integrate

Under the agreement and restrictions defined the license with appropriate usage of project.  Users are expected adhere the MIT guidelines in the licensing and its usage, with proper acknowledgements given to Krita framework and original project. This fosters respect to all involved.

## 7 Acknowledgments

Krita draws on inspiration from the research with concepts from several projects.  Key inspirations come from the design choices found distributed storage technologies.   Krita also acknowledges influence concepts in Raft algorithm and Byzantine Fault Tolerance offered within distributed systems

Special appreciation extended with libraries, tools as the Go project which enables robust concurrent framework for distributed application, providing core foundation with building distributed architecture, facilitating Krita operation.. We rely also extensively with gRPC and protobuf framework that allows structured API interactions to build reliable distributed architecture .

Contributions by individual engineers from community has played important with improving code and adding key capabilities which enhanced its capabilities in managing operations, and expanding the overall feature base

Thanks and deep gratitude expressed by all contributors with active involvement with feedback for testing to make sure the software meets requirements of a modern database and enhances project capabilities as well quality, enabling future success with Krita 

## 8 System Architecture

Krita architecture revolves as a network, utilizing decentralized peer network where the individual database operations is managed across many interconnected machines. Each individual database acts autonomously, and communicates using protocols such as Gossip Protocol

At its foundation, a gossip protocols ensure nodes dynamically maintain knowledge, propagating the network topologies among them and keeping all node states in synchronization to maintain data integrity, and consistency in the entire Krita deployment across distributed networks .

Core algorithms with Krita include the implementation and use as consensus mechanisms such as the raft to resolve conflicting writes and provide order among the different database transactions to manage state across nodes for consistency

Key data is distributed among peer database across many storage tiers and levels for redundancy, allowing quick recovery during system outage while preventing potential issues from affecting entire systems as one singular unit and maintaining operations.

Modules include: Network manager, Data persistence engine as KV storage management engine and Conflict-resolver. The data layer utilizes custom implementation as part a database engine for fast operations as data type storage and querying . 

Data propagates between node by a gossip algorithm ensuring the propagation between node, maintaining state consistency as part of overall distributed system operation, allowing network scalability to manage a vast data volumes . Finally data flow includes data requests through a API layer, and validation through Conflict resolve algorithm. This process enables data to converge on network

## 9 API Reference

Krita provides an HTTP based as REST endpoint interface for simple KV data management tasks for client application integration

Endpoints:

- /put `method=PUT key value`. This stores a KV entry in a Krita deployment with associated parameters . This stores KV entry into distributed storage . 
- /get `method=GET key ` Returns associated KV with specified identifier . The function is able to find data based associated ID and return stored values .
- /delete `method=DELETE key`. Allows removal the entry from a distributed KV storage deployment using the given parameters
- /range `method=GET start_key end_key` Provides a method of retrieval range keys based on associated key value.
Protobuf interface offers high bandwidth gRPC communication channel and optimized serialization as binary protocol, enhancing throughput as efficient network interactions between peers in Krita deployment for fast transactions. This is mainly use case in backend integration, where low latency communication required between the components for fast transaction

Parameters for API endpoints:

*   `key`: Unique Identifier, string. 
*   `value`: Data, stored with associated KV. Can store as string, number or JSON formatted values depending the implementation details.. 
*   `start_key`: The range starts as the start parameter to query the key values 
*   `end_key`: Key to determine range, used for querying. Key range to specify a set range keys, all entries in-between the start, end parameter is returned in query

Examples : To create, send the following: HTTP request POST, to put `test` :`testdata` and receive HTTP Response of - 200 with `data saved successfull` for success

## 10 Testing

The `go test` command initiates testing within Krita repository by compiling test code to generate a binary that runs unit-integration validation scenarios to determine quality of software.  Testing frameworks, specifically using a default `test framework Go`, ensures the integrity for core logic of system with consistent standards.

We utilize mock and simulated database environment during test operations, allowing controlled and isolation scenarios in test environment as testing and validation purposes, avoiding potential interferences with the external dependencies, ensuring stable and efficient assessment and performance

Unit and integration validation scenarios ensure the robustness for code implementation while detecting edge case and boundary issues to avoid issues arising during production deployments and operation with increased reliability. These help to detect early stage issues before releasing

Sample execution using terminal is performed, to evaluate testing status and ensure that testing is passing, `go test ./...`. Running these command initiates a complete execution across various modules in codebase ensuring complete quality validation of software and overall performance

We employ testing with CI pipeline and continuous build processes for consistent test validation on the latest updates with each integration of code, enhancing the quality, verification with automatic test runs. 

## 11 Troubleshooting

If your Node can connect and doesn not join any P2P clusters, verify you do not running the database under firewall with incorrect configurations, restricting access for other peers in the cluster from reaching Krita Node by default configurations for proper operation and integrate the correct ports . 

Data corruption might occur with data validation during storage operation or network instability leading the inconsistent update of state, it will try and recover by running the synchronization, reinitiating data and network to resolve data integrity problems with consistency checks .

High-memory consumption with unexpected database usage can lead system failure. This can occur when cache configuration or database settings need adjustments based actual load to minimize overall operation costs and avoid memory overload with efficient allocation strategies .

Conflicts when writing same data simultaneously across the distributed nodes and the symptoms may appear inconsistent results and data validation. Resolve them utilizing a consensus mechanism and retry operation, allowing to guarantee the proper and accurate transaction ordering across multiple databases to prevent data inconsistencies 

The issue occurs with slow database query performance during operation due resource limitations with improper caching mechani