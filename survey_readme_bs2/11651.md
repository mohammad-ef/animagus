# SmartHomeManager -- Automated Residential Systems Controller 2.0

## Description
This project aims to build a centralized, configurable smart device management and orchestration platform designed especially as a central nervous system to control all smart devices in modern homes using a modular, Python based backend.  The Smart Home Manger (WHM 2.0) facilitates a more seamless and unified way to manage and interact with various smart devices and appliances within a residential environment. By integrating a wide spectrum devices and offering robust API's.  

The project architecture utilizes a microservices framework built with Python utilizing Fast APIs for rapid development and easy scaling, alongside asynchronous tasking to efficiently control multiple device types concurrently. Device integrations are managed through plugins, enabling users or developers extending functionality and adding more support as they wish. This architecture provides high flexibility and extensibility to handle the constant influx new smart technologies on the marke.  

Our primary objective is to offer a user-friendly interface coupled with powerful automated rules and scenarios.  Users can create personalized routines such automated lighting changes, climate adjustments, security configurations or other custom integrations that streamline and improve their daily life in their household. Security and device safety is also our utmost importance.

WHM 2.0 provides robust API endpoints. Developers and users will find these invaluable to integrate with third -party apps, create dashboards of home data, and extend existing functionalities of device interactions with a centralized platform of control. Furthermore, our modular architecture supports easy addition of device and service integrations, ensuring future-proof functionality and scalability.  

WHM 2.0's design incorporates extensive logging, and health monitoring to proactively address and resolve issues that occur in operation. Our commitment to reliability and performance ensures that home users will always enjoy consistent device control and system automation without interruption to their smart device experience and their overall home lifestyle. 

## Installation Instructions
To install the SmartHomeManager, you' ll have to satisfy several prerequisites. You will require a machine or server running a supported operating system, along with an installation with the right dependencies to run the project correctly. We recommend having Docker installed.

Prerequisites include Python >= 3.9 and Pip >= 22 installed. If using a virtual enviroment is recommended but optional as the project has a `requirements. txt` which holds all project dependencies. This allows for clean dependency separation between project and global system.  The installation will involve creating an account on an appropriate hosting platform to run the system as a service, either cloud or on a local server.

After ensuring all prerequisites are met navigate to a directory on your system and `git clone https://github.com/SmartHomeManager/WHM2`. After that `cd` into that newly downloaded directory in order to run the necessary install scripts and commands for proper system installaion. 

You'll now install the python dependencies from the commandline:
```bash
pip install -r requirements.txt
```
The `requirements.txt` includes packages like `fastapi`, `uvicorn`, `pydantic`, `requests`, among others needed to run this app correctly. After this is executed ensure your packages are all correct and up to date before going ahead and installing other packages you might require

If opting to utilize Docker and docker-compose the install is greatly streamlined to simplify deployment, reducing conflicts, dependency management and ensuring portability between various enviroments:  
```bash
docker-compose up -d
```
If the installation has completed with errors ensure the logs for both docker as well the WHM backend logs have all errors addressed before further proceeding

These installation process are designed for linux operating systems however can adapt and apply the steps with a different operating system. Windows requires a WSL(Windows Subsystem for Linux) and the MacOS system is very well compatible but ensure python 3.9+ are available.  It's important to test the basic install on your OS.

The Docker install requires having an image already compiled and ready in order to proceed further in the install. Ensure there's space to accommodate all docker containers as each container may consume a good size to ensure smooth operation without system slowdown

For Windows and macOS users using a Docker Desktop you can configure docker to share file volumes so some configuration is available in those cases and you will not be confined inside a completely contained enviroment which allows easier file manipulation.
Ensure there aren 't conflicting versions for your OS, for Windows this requires a reboot for changes in PATH or environmental configuration to become visible across system services

The Docker environment is designed with the backend in a seperate contaienr so scaling individual services becomes easy, but the Docker install may still require initial memory configuration to ensure adequate performance with many concurrent clients connecting. Ensure that there are no firewalls configured which block incoming or outgoing network ports required by your SmartHomeManger.

Upon installation verify proper installation running the `curl` or `httpie` command line clients:  
```bash
curl http://localhost:8000/healthcheck
```
Successful health checks ensure that WHM and the associated database is up, healthy and operational before going into advanced use-cases or configuration stages

For a smooth deployment it helps have a stable database system available for persistence as data will get stored to manage devices and configurations which requires some kind of data integrity.

## Usage Instructions
WHM 2.0 has an REST API using HTTP requests as a main component and it supports various methods and request/response formatting options that allows flexibility. 

First, to ensure the instance is healthy check with:
```bash
curl http://localhost:8000/healthcheck
```
If successful you are getting "ok". The primary interface uses `localhost:8000`. This address might change if configured or deployed differently on your network and you might also want to change that to an actual URL of service to ensure remote usage across devices on network and internet connection.

You can get a list of configured devices, the API response for that will contain device identifiers with associated metadata and configuration, like IP address or port number to allow interaction between services with these endpoints:  
```bash
curl http://localhost:8000/devices
```
For advanced operations and controlling each specific piece, it allows POST request, PUT request or DELETE, depending what operations needed in that case to interact between components to make smart actions in home or devices.

For creating custom automated rule set and scenario you should interact using HTTP request to endpoints such as creating, retrieving updating as well deletion:  
```bash
curl -X POST -H "Content-Type: application/json" -d '{"name": "Evening Routine", "devices": ["living-room-light", "tv"], "actions": [{"device": "living-room-light", "action": "on"}, {"device": "tv", "action": "off"}]}' http://localhost:8000/rules
```
Advanced usages includes integration between various devices such Z-wave hubs with API access. MQTT protocol integration is available. It requires proper credentials setup and authorization which can affect security patterns

API usage is also possible using authenticatoin with keys that can be managed within configuration files. Proper access control will allow careful access based roles, limiting who has authority of controlling certain services within this ecosystem

You might also want to integrate it with voice assiatnts for controlling actions by speech. For these you will require proper authorization with the services of such assistants for a safe experience with proper device access control. This integration might require custom configuration depending with different service platforms to enable seamless operation.

When working with large data sets and multiple concurrent operations consider optimizing the request and using appropriate cacheing strategies. You also must monitor for any error responses, especially for network related connectivity, to improve performance with feedback

The UI can show device health status.  A simple health check page with real time data for various services running within WHM allows for easier monitoring, diagnostics and error tracking

Proper testing will help you find edge cases, improve stability, performance.

## Configuration
WHM 2.0's flexibility in deploying different configurations for different setups can easily allow you change aspects like logging levels for better error tracing to database configurations. This makes system more reliable

Configuring WHM 2.0 typically requires setting parameters either using environmental variables to manage configuration or editing a configuration YAML/JSON files that specify different components for services like device management modules and security parameters

Environmental variables can be useful for secrets management and sensitive keys as that helps to reduce direct inclusion inside files, allowing that for a safer setup: for instance DATABASE_PASSWORD,  API_KEY, and DEBUG mode, among many other configuration values that help to change different parameters without needing full system redeploy. These configurations help in minimizing deployment errors.

If editing JSON configurations file make sure it adheres strictly to schema, because it might cause failure for service startup. Furthermore validation steps for data can be applied to catch configuration error before services starts, allowing you fix those quickly before system fails to run correctly

The YAML or JSON files define default behaviors. Different modules may support different configurations like timeouts for connecting with a Z-wave device. Device specific configurations might need individual parameters. These are important in tailoring how different hardware and devices integrate with your smart environment

Plugins are essential parts to allow integration. The plugins configuration allows customization with various modules. Plugin configs should follow standards to minimize issues, for easy maintenance and extension in various device integrations, or third-party platform integration. This will also help with security by isolating integrations and their impact with main application and services.

If your WHM instance running under reverse proxy configuration then configure proxy pass through, and configure upstream for your application to correctly access WHM's services, which are common for running with container deployments or web application servers to make the app externally reachable with custom routing or subdomains for easy deployment in different cloud hosting setups

As a part of the config you also want ensure logging level configured as proper for tracing any system error in a way to quickly troubleshoot problems when needed to reduce time needed to resolve them effectively to prevent long down periods, especially in production setups

To ensure data consistency database parameters need configuring properly for persistence and scalability for large datasets, ensuring that you use a suitable choice of DB system with parameters optimized to prevent performance degradations for large numbers of operations, as the amount of individual device integrations will keep getting scaled and grow as needed, so that you have proper scaling options for persistence

For testing environments it recommended configuring mock or temporary database connections and setting debug modes so issues get tracked and fixed efficiently and fast during various development iterations of services or integrations for sure quality and performance improvements and quick feedback to improve code quickly

## Project Structure
The repository employs a logical structure to improve code manageability, organization and extensibility to facilitate collaboration

```
SmartHomeManager/
|-- README.md                # The Markdown File explaining all project info
|-- requirements.txt         # Dependencies for the entire system
|-- app/                      # Root source for all app related functionalities
|   |-- __init__.py         # Makes directory as Package Module
|   |-- main.py            # Startup and configuration point for app, connects modules.
|   |-- modules/             # Directory holding device plugins for extensibility.
|   |   |-- zwave/
|   |   |   |-- __init__.py
|   |   |   |-- zwave_manager.py # Plugin code interacting Zwave hardware/API.
|   |-- devices/               # Contains Device related API routes to access/azure/delete etc.
|   |   |-- router.py           # Contains device-route related definitions/functionalities
|   |-- schemas/           # Pydantic Schema models and data definition for requests.
|-- tests/                    # Automated unit testing suite
|   |-- __init__.py
|   |-- test_main.py         # Main entrypoint test file with specific modules/endpoints to cover.
|-- docker-compose.yml    # Configuration files defining the structure and docker environment of application services.
|-- configs/               # Stores all external config file like .env. yaml configurations
```

The project structure separates application logic, configuration parameters from data-persistance layer as different logical locales in the repository. `configs`, holds various YAML files to allow custom parameters and configuration to control various components in this platform to easily custom configure. `devices/`, houses various API endpoint definitions for different services, which are managed using FastAPI's framework and `modules/` which handles several device related extensions for plugin based interactions that allows easier expansion for new technologies.  It uses Pydantic Schema for all the request body validation

## Contributing
Contributors play key role for expanding the features to make this open source project grow with contributions that improves the whole platform's experience

To start submitting code follow instructions on `README` on submitting PR for various issues, ensuring codes follows style guideline that is set and adheres the project structure defined to ensure quality standards in changes submitted as well code style conventions in python. Testing should cover the code you are adding with integrating APIs and services involved in your code and making proper documentation of any features.  

The issues reporting follows the guidelines and best practies. Describe your problem or features that needs fixing as descriptive a format and provide details to reproduce as that helps in resolving those issues effectively as fast and accurate and to ensure your code works and is properly validated to make changes that work well in various system conditions, so please test before submit as a Pull Request to minimize conflicts and improve integration with current state as that reduces time in validation process for merging into project

Coding styles must match python standard which helps maintain consistent style to minimize any issues when other contributors merge codes in, and it makes the entire platform readable, consistent with proper indentation. Proper commenting helps understanding intent as well code behavior. This allows other contributors quickly review, and validate the functionality that your are integrating to platform with less friction

Testing is essential when integrating or modifying functionality. The code will have automated checks, to validate functionality as the platform scales with new device types that are introduced as this allows for easier maintenance in long-run and helps avoid regression and performance problems

## License
SmartHomeManager is licensed under the MIT License. See the LICENSE file for more details on rights granted under terms to users

As per terms usage of license you may copy use modified the program and its parts if and if the software copyright information included as part, and the usage for the purposes. It also allows for derivative and modification without needing any licensing changes for use

## Acknowledgments
Special thank's towards OpenSource communities, contributors that provided libraries, tools and documentation. We're using many of the standard components available, that are available, so the system works well for various use. We also thanks Fast API contributors and Pydantic for their great work

Also want thank the python language creators, along their communities.  Community contributions help with expanding and evolving the platform to meet diverse usage cases and improve its stability. Thanks as well to our internal test users. They are critical contributors with testing feedback

Finally thanks to everyone helping test with our software to find various issues with their home and their smart environment setups as these issues have provided valuable guidance for platform to become even stable, robust as well as useful as time progress, improving overall experience with this open-source smart solution.

## System Architecture
SmartHomeManager adopts a distributed and modular approach designed for extensibility, and maintainability with clear separations

The main service uses FastAPI framework that hosts various API's with separated routes for various operations that handles data and communication, as well it also manages configuration, and logging functionalities, and it provides entrypoints that other components utilize when accessing data as the application requires

Device Modules, these act plugins for interacting various SmartDevices. They provide APIs and logic needed interacting, configuring and querying device specific data, such with integration using different hardware or services that require device interaction as a plugin-base allows extensibility. The modules use message broker system such with MQTT as a mechanism, allowing decoupling, scaling components

Configuration service responsible to loading configurations, validating and storing device settings to database, which provides central location, so services access data with proper authentication and validation, ensuring consistency and access

We use database server (SQLite) with storing stateful configuration, user accounts with authentication as this provides centralized persistent configuration data. We utilize database connection-pooling as a mechanism which allows to prevent overheads when services frequently accessing databases with minimal overhead as performance

## API Reference
A comprehensive listing and reference to endpoints are provided below here with all details. All endpoint supports HTTP verbs GET, POST, PUT, DELETE, as a main operation, allowing to perform operations for various API's as the requirements of system

**/healthcheck** `GET` endpoint for service to be alive with HTTP Response Code (200 OK)
**/devices** `GET` list available, `POST` adding new Devices and configurations to service and storing related metadata
**/rules** `GET` lists automated rules configured within SmartHomeManagement. It supports  `POST` creating automated actions or rule and updating with using POST. DELETE for rules
`/auth/register` register a user
`/auth/login` Login

All of them return HTTP Status with 200-400 or other error statuses with details and description.
Example request using POST method
```
POST http://localhost:8000/devices
Content-Type: application/json

{
"name": "My Smart Thermostat",
"type": "thermostat"
}
```
Returns 201 on create

## Testing
The automated tests help guarantee code integrity. Automated test includes various unit tests, which validates the logic in separated module to make the entire components more maintainable
To Run the Unit and integration test the steps: 
```bash
pip install -r test_requirements.txt
pytest
```
Ensure proper configuration before execution, as test environment replication and dependencies may change for proper smooth running

More unit, and system tests should always cover new additions for code validation before integration. Failure for unit testing may require fixing or modifications to codebase. Proper unit tests will make future refactoring, development more robust. Integration is performed with different components with different device integrations to guarantee the system works seamlessly when scaling with devices

## Troubleshooting
Encountered Installation issue requires careful diagnosis: If dependency not installing ensure python and `pip` version compatibility with dependencies. Ensure proper file access as well system rights with file system permissions if you get issues during file read. Check Docker version as sometimes cause unexpected installation error with Docker environment if it has an unsupported format or old installation state

Network errors are caused usually incorrect configurations. If connection fails e.g Z-wave or devices verify network access, configurations. If you have reverse proxies confirm routing, forwarding are all properly defined to make back channel connections possible
```bash
netstat -tulpn #Linux/ MacOS command, helps in tracing connection states with port information.
```
Log Files provide insights in troubleshooting errors.  Review logs with proper configuration. Look into application level log or database for useful details for errors and failures. Check container health for any errors with running container states with docker

Database related issues require validation that database connection and user authentications is working correctly, verify schema matches to ensure there data can get saved.
Incorrect configuration values are the biggest sources that contribute for failures with service. Verify YAML or env configurations to catch typos errors. Also test changes to configurations before deployment in the actual live enviroment

## Performance and Optimization
Performance and scalability is achieved in the modular system with distributed microservice, so individual services may operate separately. Database pooling can minimize connection time for data queries and improve efficiency

Cache data is stored with frequent requests for faster response time. This can involve database caching to memory as caching layers for commonly retrieved values as it reduces overall query overhead for data
Async operation can handle concurrent request, and it is essential to reduce overall latency in operations and allow system to manage higher load without degradation with multiple clients. Asynchronization also ensures resources are allocated and efficiently f