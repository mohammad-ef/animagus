# Task Scheduling System - TSSv5 

## Introduction
TSSv5 is a sophisticated job/ task execution platform designed for automated workflows. It facilitates the scheduling tasks, their dependency management, execution and tracking. The core aim is to minimize resource consumption while guaranteeing job completion based on specified dependencies, and resource constraints. It is built around an architecture that emphasizes modularity and extensibility. 

## Description
TSSv5 solves the problem of manual job coordination across different server locations.  Previously, this involved cumbersome scripting and constant intervention, often leading to failures and delays. This system offers an automated and reliable alternative that reduces human effort and improves job completion reliability. Its central scheduler component efficiently manages task prioritization and resource utilization.

The platform uses a message- queueing architecture.  RabbitMQ is leveraged for reliable task dissemination and acknowledgement. This allows decoupled worker node processes allowing individual node restarts or maintenance while ensuring that all tasks are processed. The core scheduler component uses Redis to efficiently store and manage scheduling data including tasks, dependencies, and worker node information in memory.

Furthermore a web-based UI provides an intuitive interface to monitor task progress with interactive visualizations and reports. The UI can be customized via a configuration file, providing users granular control over its functionality and layout. TSS is capable of running a wide array of tasks through its plugin ecosystem.

Finally, TSS offers robust error handling mechanisms to manage task failures and retry jobs based on pre-defined conditions, preventing job failures and ensuring overall system resilience.  It provides a complete job scheduling and execution solution.

## Installation Instructions

First, install Python 3.8 or greater. This system is primarily built in Python and relies on several key packages which can be installed.  Make sure you have pip installed as a part of your Python installation for package management. Verify Python installation by entering `python3 --version`

Next, clone the repository from GitHub.  This will create a directory with all the project' s code, documentation, and configurations. Use the following command in the terminal to clone the repo:
```bash 
git clone <repository_url>
```

Change your working directory into the newly cloned project directory:
```bash
cd <project_directory>
```

Install the dependencies defined by the `requirements.txt` file using pip :
```bash 
pip3 install -r requirements.txt
```
This command retrieves all the necessary packages from Python Package Index (PyPI) and installs them in your virtual environment. This step will install RabbitMQ and Redis python bindings.

Now you have to install RabbitMQ. On Debian based systems you can install using:
```bash
   sudo apt-get install rabbitmq-server
```
On RHEL based systems use:
    ```bash
    su -c "sudo yum install -y rabbitmq-server"
    ```

Then install Redis:
```bash
sudo apt-get install redis-server
 ```
On RHEL based systems use:
  ```
  sudo yum localinstall --nogpgcheck redis https://yum.postgresql.org/13/redhat/x86_64/repodata/repomd.xml
  ```

Configure Rabbit MQ by starting and then running:
```
sudo systemctl start rabbitmq-server
sudo rabbitmq -username admin -password password  --plugin management
sudo systemctl enable rabbitmq-server
```

Start redis
```
sudo systemctl start redis-server
sudo systemctl enable redis-server
```

Configure your database, you need to have postgres. Create database and a user for your program
  Project has a local config that should override all default configs for quick testing

You need to have a valid Postgres DB connection and create it in local configuration

Ensure your server environment is appropriately set.

## Usage Instructions

The primary command for the project is `tss_scheduler`. To start the main scheduler process, execute the following:
```bash
python3 tss_scheduler.py
```
The scheduler monitors incoming tasks via RabbitMQ. Logs for tasks in processing and completed can be reviewed locally via file

Tasks can be submitted by posting messages to the specified RabbitMQ exchange (defined in the configuration file).  Messages must contain metadata such as the task name, script to execute, dependencies, priority, and associated arguments.

Example: `tss_task_sender.py`.
You must first set it up as described below with `tasks.yml`.

```bash
python3 tss_task_sender.py --config_file tasks.yml
```

The system also features a REST API (on port 8080 by default) providing basic functions and API's for job status updates, configuration modification and more advanced functionality via API call. This API can be called directly through HTTP libraries and other external programs to automate complex task sequences

A UI webapp for visualization exists on localhost port 8888
For basic testing of job dependency resolution you may need to use an environment file that contains dummy tests, to be used by an initial worker that simulates execution and sends updates. This can also provide a basic demonstration on monitoring job state updates and schedule modifications

Advanced tasks require the creation of plugin extensions which are placed inside /plugins/ . These extensions need to have an `init` call and can extend base `JobPlugin`. These will register as an API to run the given function. These will have full system capabilities as a privileged user with full control of underlying infrastructure and are used for sensitive or system critical functionality

To test with a dummy function you need to first create `my_dummy_func.py`:
   *Create the `init `file that imports the functions that must be ran,
  ``` python
   from my_dummy_func import dummy_job_execution

  ```
*  The dummy task file
  ```python
  def dummy_job_execution():
   print ("I am running my custom code.")
  ```

## Configuration

The TSSv5's behaviour is highly configurable, allowing users to fine-tune its functionality based on environment specifications. Key configurations occur inside the `/config/config.yaml`

Environment variables play a critical role, overriding the YAML configs, providing more portability and security through sensitive values and credentials storage, for sensitive configuration data like RabbitMQ credentials, Database passwords, external API Keys and other authentication information which will never reside on the file-based configuration for safety, they will need to reside within your deployment system and be configured through your operating system, for better security

For task scheduling priority you need to specify values between 1, 10 . Priority levels are evaluated when multiple task queues occur

Worker resource configurations, you specify maximum cores per processor or amount of RAM. These limits apply on an instance level so if multiple workers reside, the limits should correspond for overall capacity utilization, which prevents overloads that would affect overall throughput or job stability. The scheduler automatically manages these based on current resource utilization levels on worker. This also ensures proper resource usage

The `task_queue_timeout` property defines maximum amount of seconds that the jobs are available inside queues, to provide resilience and avoid jobs to accumulate and never processed when there might be a temporary worker outage . It ensures the timely retry mechanism to prevent task failures from being permanent

Plugin paths specify locations for custom scripts or integrations. These must exist under `plugin/`. The scheduler scans and initializes these scripts, which extend existing features to the platform to update task status, and add new features such as reporting, visualisation, etc. This also supports custom task processing and allows the creation of dynamic plugins

## Project Structure

The TSSV5 is organised using directory tree, allowing modular components each fulfilling dedicated purpose within system.

* `src/`: Source code of project.  The main module for scheduler and the related logic for managing, tracking the jobs exists.
* `config/`: Project configs. YAML files containing configurations for the server and job queue.  Includes default parameters as a starting configuration template
* `plugins/`: Contains plugin implementations. Plugins that extend specific tasks and functions, and allows to dynamically integrate and execute additional functionality and features into task pipeline without core system modification.
* `tests/`: Automated tests, containing integration test cases. Tests can simulate different conditions.
* `scripts/`: Shell script. Utility functions used in project, e.g scripts needed for deployment tasks or data migration

This layout enhances organization. Source and tests remain decoupled from each other and allow the development and deployment process

## Contributing

Contributions to TSSv5 are highly encouraged to foster continuous improvement. Please first familiarize yourself withe the guidelines below to avoid any potential conflict, or unnecessary rejections.

Create a detailed description outlining the bug report before you start to submit issues to github issues page. Ensure that the issue is clearly described to avoid any ambiguities to other potential developers, including stacktrace if applicable

When implementing any change always adhere the code formatting standard to make project readable across all team developers to prevent potential conflicts during integration or merging, and make integration easier to perform by avoiding unneccesary refactoring steps that may break the functionality
All new functionality or improvements needs comprehensive automated tests before it will be merged for validation. Tests will run before merging and can fail the merging operation to enforce stability and robustness, which avoids breaking the overall platform, which may lead to production failure. Ensure adequate unit/integraton testcases exist and all edge-cases tested
Ensure proper documentation to describe functionality changes for easier usage and debugging and allow for better maintenance, and scalability across all future development stages
Pull Requests should always target a branch which is based upon master to prevent potential merging conflict,

## License
This project is licensed under the MIT License.
Please be informed that, it can be freely used for personal, educational or commercial purposes with attribution

This allows modification to project to suit the requirements and usage needs while preserving original authorship with minimal usage rights limitations, ensuring broad usability for the wider public, without excessive constraints that might impede adoption

## Acknowledgements

The team extends heartfelt thanks to contributors, who have dedicated valuable hours to refining project features

A special appreciation for those providing assistance within communities and offering helpful insights that significantly impacted our overall platform design

Thanks also extends to RabbitMQ & Redis open source contributors that helped with libraries which provide a core/ backbone functionality to manage asynchronous communication between different nodes in project ecosystem which provides resilience & optimal performance in task orchestration.  Without these projects TSS v5 will be highly constrained & unable to meet our current needs, or provide our customer requirements with the required levels

Lastly, gratitude given for inspiration taken from other task execution and scheduling projects.

## System Architecture

TSSv5 utilizes a distributed message queue driven system with modular, plugin oriented extension framework, allowing to support multiple workflows

RabbitMQ acts central message broker. This decoupled components from task scheduler. The system can run and manage task asynchronously which is ideal as job queues build upon this and prevent task failure when worker processes encounter errors and allows tasks that will still continue execution

The main Task Scheduler is core logic component to monitor message exchange on broker which evaluates dependencies and assigns the tasks.
It maintains a state in redis to efficiently determine available task queues to run tasks. Scheduler manages overall system, resource, health

Job Execution Engine: Plugins implement specific business rules for processing each job and can dynamically load tasks as well and provides extensibility without code changes on primary application core which is an ideal for integration

RESTful API is available. The APIs provide a convenient, and scalable, integration interface. Clients and monitoring applications communicate, track and receive task state

The system leverages containerized environment. It can leverage Docker containers. These can scale horizontally with Kubernetes allowing efficient deployment across clusters and ensuring the overall performance with flexible capacity. The containers also isolate task run environments for increased resource usage

## API Reference

The following provides basic description about TSS v5 API. For detailed specifications consult separate `swagger.yaml` specification
* GET /status  -> Provides overall service and job states for the application to ensure the running state of jobs is consistent

* GET /task/\{task_id\} ->  Retrieves details related specific given task_id which include state updates, logs or dependency resolution or execution. This enables tracking the current process of any specific task
* POST /task  => Sends a tasks, it takes the YAML file which defines dependencies as input, which is a new way to create new task queues

* PUT /config - > Updates configurations and properties, allows changing RabbitMQ connection and configurations
  For advanced usage and customization you must consult separate `API` specification.  These can be manually modified or automated via API.  Ensure proper testing occurs with automated scripts to validate functionality across API integrations before production usage to ensure stability in a distributed system and scalability with large volume requests
## Testing

Tests ensure that TS V5 works consistently in production

`pytest` provides test framework for Python. The testing suites cover a large portion code base.

Unit tests validate the correctness. Unit test validates functionality within modules in the isolation

Integration test simulates a complex workflow by integrating all core functions to simulate end to end scenario.

The integration runs after publishing new version, ensuring stability before deploying

The system can automatically create dummy data with predefined dependencies which provides an efficient method, ensuring a robust and stable release with high level coverage of the functionality to guarantee stability across various platforms and use case and continually improve reliability in long runtime operation, to provide consistent output
To perform unit and integrations test please ensure environment variable set. Run the script

   ```
   python3 test.py
   ```

## Troubleshooting

Issue 1: Failed connection with RabbitMQ server:
Verify connectivity and that rabbitMQ process in healthy and operational on both hostnames and network

Ensure your configuration in the `yaml` file is properly specified and that RabbitMQ username and credentials matches the setup on environment, otherwise the process might experience a connection problem that stops job creation on system

Issue 2: Job failed after long execution with `time limit`,
Increase value to increase processing limits if required for more demanding operations and consider to add error logging.
Check your code logic in respective `Jobfunc`, it can also provide details errors during job processing for proper debugging steps on execution path, which enables developers find errors.  
Make it configurable via config files to adjust the limit as a configuration setting to allow customization to match workload. This helps to adjust runtime behavior according need with external environment changes to prevent job errors, or improve processing throughput based

## Performance and Optimization

TSS v5 focuses on resource-efficient design with minimal system resources to maintain responsiveness even with numerous job requests in a busy cluster, and optimize task execution performance to prevent long latency

To boost processing capabilities we use caching mechanisms for data, reducing latency during task processing for quick retrieval of commonly accessed variable, to minimize network latency when processing a huge workload
The architecture of this application uses asynchronous communication via messages and queue.  These allow to handle tasks simultaneously by scaling horizontal scaling by adding new instances with multiple workers

We also use a Redis as a persistent store to cache job status for performance gains to ensure minimal data transfer for quick lookups, improving speed by caching the results of calculations

Profile code regularly through code profilers which help identify bottleneck to prioritize improvement opportunities

## Security Considerations

The application requires careful security practices to secure jobs, protect against security vulnerabilities from untrusted source

Validate external API request with validation libraries before execution and enforce authentication mechanisms versus API

All passwords should store securely in secure key stores like AWS Vault or equivalent

The platform is vulnerable.  The plugin code runs elevated access to resources and systems so must be verified to mitigate any code execution vulnerability

All external connections with external network should require proper network firewalls, to protect against outside unauthorized attacks or intrusions on critical assets.

Ensure to patch software vulnerabilities. This includes libraries.  Implement automated vulnerability scanner on code, to ensure continuous monitoring with automatic patches and mitigations when vulnerabilities arise which helps reduce attack surfaces, making overall infrastructure robust, reliable.
This ensures overall protection reducing risk of attacks from various external resources and protects critical data from unauthorized use to safeguard business continuity

## Roadmap

**Phase 1 - Core Enhancements**
* Enhanced Task dependency engine, for increased scheduling reliability
* Implement improved job queue and management

**Phase 2-Advanced features**
* Support custom Plugin development using new SDK with API documentation and example implementations
* Introduce real-time dashboards for visualization
* Add advanced analytics reporting. Implement comprehensive dashboards

**Phase 3 - Platform Scaling**
* Integration for other messaging services. Extend RabbitMQ integration, allowing to work in connection across multi messaging systems and environments

* Support of cloud deployment for easier and efficient cloud- based scaling and resource consumption. Enable container support

**Phase 4:**

Implement support on multiple task processing languages. Expand to allow for running scripts written languages.
Automated scaling on demand with Kubernetes and auto configuration to match system capacity based on metrics driven approach


## FAQ (Frequently Asked Questions)

What are minimum required requirements for deployment of TSSv5. Requires minimal resources, but performance improves scaling resources
The system will need approximately `8 GB memory ` with a CPU with two core to execute the tasks.
Ensure OS has adequate dependencies to execute the program, he system needs to have access with `python version`. Ensure you are utilizing current python releases
Why am unable to submit my custom code via new `plugin`, and what are the limitations

Plugin code executes using privileged system rights.  It has to run through strict verification checks for code validation for safe code integration. Ensure to adhere guidelines on creating the API and plugin implementations with proper documentation, code reviews, to adhere secure best practices to mitigate code vulnerabilities during deployment. If issues encountered review documentation, or report any error

How to increase efficiency? Ensure the task scheduler properly allocates the workers to avoid over allocation

How long must wait to complete all running process and what the status

Check RabbitMQ, to perform an analysis

What does error 503 mean ? It implies that application can process request at current point of time
Verify server load. Verify Rabbit MQ connection with the service to ensure there is a valid and working message flow for all operations,

## Citation

This can be referred using the following
BibTex Entry
```Bibtex
@software{TaskSchedulingSystemv5,
  author = {TSS team},
  title = {Task Scheduling System - TSSv5},
  version = {5.0},
  year = {2024},
  url = {<project_repository_url>}
}
```

Please attribute as `Task Scheduling System V5. Developed by <TSS team>` or <cite>{TSS team}.2024` to provide accurate and transparent attribution when integrating this platform or incorporating its features to academic works

## Contact

For questions and bug fixes or suggestions please create ticket to github
Community forum exists on `github`. Join for collaboration to share and contribute to this project to further extend the features of our project to support various integrations. We also support community support through an active discord community where active users can help debug any issues and share insights for better utilization of our features