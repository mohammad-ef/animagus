# Simple Task Scheduler (STS) - A Python Task Execution Framework

##Description 

STS is a powerful, flexible framework designed to simplify and robust schedule execution of Python tasks. Its architecture emphasizes modularity, enabling the integration of different task backends and scheduler engines.  STS aims to streamline development, deployment, operations, monitoring, error management, and reporting of automated processes, reducing overall operational complexity and enhancing system robustness by managing task dependencies and error handling.

It allows for the scheduling of tasks based on a variety of time constraints - from recurring events to scheduled intervals. A core component of our scheduler is built with event queuing, ensuring efficient task delivery and minimizing delays.  STS is also designed to be extensible through a plugin mechanism, enabling users to add specialized schedulers, persistence mechanisms, monitoring and alerting integrations without altering the core codebase directly.

The framework's primary goal is to replace brittle ad-hoc scheduling mechanisms, such as cron jobs and basic loop scheduling, with a centralized, manageable, and resilient system.  STS supports a wide variety of task types, from simple scripts to intricate database operations with the added benefits that include automatic retries, error logging in a centralized location that supports alerting. It's particularly well- suited for automation in cloud- native systems or applications. 

STS is built for easy operation, monitoring & integration, featuring REST API for remote task creation, modification. It supports a wide range of persistence and scheduling mechanisms, including in memory for simple tasks and persistent queueing (Redis/ RabbitMQ) for complex production environments requiring robust failure resilience.  STS provides a comprehensive and extensible architecture to handle the needs of any automation workflow, and is designed to scale and adapt alongside your needs.

STS also offers comprehensive task dependency management ensuring tasks run in the correct order while handling failures appropriately. The task execution can be logged into the system for debugging purposes. STS is also designed to integrate with a wide range of monitoring tools for proactive alerting. STS is also designed to allow developers to add more task types easily.

## Installation Instructions

To begin with STS, you will need Python 3.7 or greater. It is highly recommended to use a virtual environment.

```bash
 python -m venv sts_env
```

Activate the virtual environment:

  *   **Linux/macOS:** ` ./sts_env/bin/activate`
  *   **Windows:** ` sts_env\Scripts\activate`
    
STS primarily uses `pip` as its dependency resolver and installer. You can install the package with the following command using `pip`:

``` bash
 pip install SimpleTaskScheduler
 ```

Make sure your `pip `is upgraded as well before installing the STS package: `pip install --upgrade pip`.

This installs all the required dependencies, as specified in the `requirements.txt` file within the project. The project requires that you have python 3. 7 or greater.  This can typically be downloaded and installed directly from python.org.

If you have a proxy configured and `pip` does not work correctly, ensure the necessary environment variables `HTTP_PROXY` or ` HTTPS_PROXY `have been appropriately configured with the proxy server and port details. 

You may also consider updating `setuptools` before proceeding with any installation to ensure a successful install: ` pip update setuptools`. It is possible that you also may need ` build essentials`, this can be fixed installing with command ` apt-get install build-essential` for Debian-based systems, or equivalent on different platforms. 

If the install fails, make sure the correct Python version is selected, and the environment variables (particularly PATH) are correctly configured. Check your Python installation's location and update the relevant environment variables accordingly.

## Usage Instructions

After a successful installation, you can start scheduling tasks using the STS API. First, import the STS core components:

  ```python
  from sts.scheduler import TaskScheduler
  from sts.task import Task
  from sts.config import Config
  ```   

Create a basic task:

```python
task = Task(
   name = 'basic_task',
   function = lambda: print("Running basic task!")
)
```

Initiate the Task Scheduler, and start adding Tasks:

```python
scheduler = TaskScheduler(config=Config())
scheduler.add_task(task)
```

For immediate task execution, the run() method can be invoked, or alternatively for scheduling to run after delay. Note scheduler.start will automatically add a scheduled task and start its operations:
 ```python
scheduler.start()
```

Running a more sophisticated scheduled tasks requires more configuration within STS, for instance specifying intervals, retry conditions and dependency relationships, this configuration must all occur via a task file.  STS will parse each of them.   You may want to consider running tests with `pytest`, for this please refer to the 'testing' instructions in this file.  It may involve the use of mock data as necessary. 

STS also supports a comprehensive REST API to schedule task remotely which enables easy management via external clients. 

You can create new jobs using: `curl -X POST -H "Content-Type: application/json" -d '{"json_object":'

Advanced users can extend TaskSchedulers functionality by plugging custom tasks in and creating a task queue with specific requirements and constraints to meet operational conditions and system constraints. 

## Configuration

STS offers flexibility through a robust configuration system that controls scheduling frequency, logging, persistence behavior, etc. You can load your settings from YAML/JSON files via STS' Config component, or just create a new config with default options using Config():

STS uses `configs/default.yaml` for loading defaults settings if not configured via programatic initialization

   ```python
    from sts.config import Config
    config = Config.from_yaml('configs/task.yaml') # loading configs
    ```
 
STS's experimental logging feature can be enabled in configuration by setting loglevel as:
``` yaml
  logging:
      loglevel: DEBUG
      output: stdout
```

STS supports configurable backend connections using a key named 'scheduler_backend' that can either specify redis queue connections as 'redis' , or for an in memory setup, the scheduler_backend may have value "memory".   STS allows users to modify all other scheduler and tasks parameters through this ` Config ` component for full operational freedom and configuration flexibility

Task retry attempts may be adjusted inside your configs file as 'retries', and also a delay before attempting a task to resume.  Error and output may be configured using log_file or standard error. The STS scheduler can also accept persistent storage of tasks for a production ready deployment and resilience to failures with a queue. 

STS is able to support various task dependency chains which requires careful task configuration.  You need to explicitly create dependency relations using 'parent_tasks'.   These tasks will wait for the listed dependencies. This can improve reliability and consistency for complex operations by making a system that depends heavily on other parts in the workflow run as intended

## Project Structure

The STS project structure promotes modularity and readability. Here is an overview:

 -  `sts/ ` The project core module
  -  `sts/core/ ` contains base class for tasks. schedulers and configurations
   - `sts/task/ `  Contains definition and related operations regarding ` Task`.
    -  `sts/scheduler/` contains implementation of different schedule engine and task delivery mechanism
     - `sts/config/` Contains ` Config ` implementation with YAML loading/ parsing

-  `configs/` Directory containing configurations, such as: `default.yaml` and `task.yaml` for testing/ production

-  `tests/` contains various task execution/integration checks to improve the overall quality

- `tests/conftest.py` - setup pytest environment with testing data to speed testing execution time
## Contributing

We welcome contributions to STS! To start contributing, fork the repository and create a new branch for your feature or bugfix

Submit pull requests with comprehensive descriptions. Code style consistency and unit tests for all additions are strongly encouraged and a requirement.  Code quality standards can only be met when following these steps to make STS even better!   Before contributing code, consider creating issues in our tracker describing changes. This guides the discussion and makes reviewing pull requests easier and less time consuming! Follow coding standard by following python coding conventions to avoid future errors during the deployment or operation phase. Ensure you add proper documentation when creating any classes to expose their functions.
## License

STS is licensed under the MIT License. The license allows users to use, modify, and distribute the software for commercial and noncommercial purposes, with few exceptions, which are clearly described at <https://opensource.org/licenses/MIT>. The full license file (LICENSE.txt) contains detailed rights, restrictions, and obligations, including liability disclaimer and intellectual property claims of the copyright holders and distributors of the project. Please ensure that usage and contribution adhere to this policy for legal clarity!

## Acknowledgments

STS is built using contributions of a diverse and vibrant Open-Source community that helped in improving quality of software in every way from coding to reviewing to adding test examples to provide documentation.  Special acknowledgements goes to `asyncio` community, as the core asynchronous event management and queuing relies on it's capabilities!   This enables high efficiency of operations, as multiple task can run independently on a limited number of CPUs while keeping things fast & simple, thanks!
## System Architecture

STS utilizes a modular architecture based around three key components: Tasks, Schedulers, and Configs.

Tasks represents individual work units and provide functions.   They have configurable options, like parent/dependancy relationships to run them with appropriate timing

The scheduler takes tasks to process according configuration.  Different engines, can plug to handle persistence of tasks, as they get scheduled and/or run and provide the functionality and features

` Config ` module reads configs and applies the changes and options in STS' execution to improve operation.  
Data flows as follows: Tasks being generated through an input source (like a configuration) gets added and managed into Schedulers for running them on specified timeframes. `Config` settings drive behavior in terms of error logging as an important aspect for tracking.  It uses async-IO and threading as underlying mechanisms which enables efficient task management

## API Reference

**Task API**

 - `create_task(name, function)` - Creates new ` Task`.
 - `add_task(task)` - Registers the ` Task`.
 - `cancel_task(name)` - Cancel registered task, removing all references and scheduled times for that task
  - `delete_task(task)` - Deletes a specific tasks instance, if available
 
**Scheduler API**

- `add_task(task)` adds registered Task for processing to schedule queue

- `remove_task(task)`: Delete Task, which removes its scheduled times.
 - `start()` Start scheduler engine. If scheduler already in memory or in a database (like Redidis ) this operation should resume existing operations from that place in persistence mechanism

- `stop` Stops Scheduler

**Config API**

 -  `from_yaml(filename)` loads configs
  -  `save_config()`  saves all settings into the file in `Configs ` module


## Testing

To run the test suite, navigate to the root directory of the STS repository in the command line. Use a testrunner (e.g. pytest or ` nosetests` ):
 ``` bash
 pytest tests/
 ```
Make sure pytest version meets requirement as well by doing
``` bash
 pip install pytest --upgrade
 ```

STS' `test/conftest.py` contains a configuration of pytest environment for running test quickly, which can greatly decrease running execution and allow to iterate faster! 

If any unit checks failed it means there were failures or errors with task or config settings or code implementation, which may cause failures! It may be due to dependencies as well and require updating.
## Troubleshooting

*   **Error:  `ModuleNotFoundError: No module named 'SimpleTaskScheduler'`**:
    Verify the package installation. Check for environment conflicts, such as the project running within multiple conflicting envs!
*   **Tasks are not scheduled properly**: Confirm that configurations (configured timezones are valid) settings.
*   **Scheduler not responding: `Error, connection failure `**: This usually means that redis instance or connection configuration failed during initial connection. Confirm credentials
* **Dependency issues between multiple tasks are creating errors. : `Task Execution Order` errors:** Double check task dependency and queue settings for all task dependencies correctly

## Performance and Optimization

STS utilizes Python`asyncio `library under-the-hood to maximize I/O throughput, as a lot of operation can go to other machines or other APIs without having much of blocking issues

STS offers several strategies, as running multiple tasks can cause performance bottlenecks in certain conditions; for this, using multi process can alleviate the CPU and improve speed in processing concerns! Caching data in a key/value datastore or using in-memory storage to improve latency

For long tasks running consider asynchronous task execution with background process management and tracking!  Consider the task's I/O capabilities when setting up the environment to ensure they work efficiently in parallel or asynchronous execution environments!
## Security Considerations

Never store passwords directly into source files in ` Configs/task.yaml`, consider utilizing secure password managers or environment-aware configurations.

Input from configuration files are not always guaranteed for security. Ensure proper sanitization for user data and input before processing it to ensure no unwanted behaviors and prevent injection-like exploits that will damage your system

Implement access restrictions to scheduler REST API using authorization/ authentication, such as token access

Always stay aware about recent vulnerabilities of any used packages to ensure that STS does not inherit these potential vulnerabilities in future updates. Keep dependencies-patched with a security-oriented package and monitor security updates! 

## Roadmap

- Support additional task execution engines (celery) - **[Feature Complete!]**
- Enhance error alerting via Slack - **[Priority in progress!]**
-  Support task versioning with configuration rollback functionality for ease of testing

- Improved monitoring & dashboards
 - Task queue metrics with health and throughput tracking for proactive alerts


## FAQ (Frequently Asked Questions)

*   **Is STS easy to deploy?**  Yes, it uses common configurations. You simply have to set `scheduler_backend = 'memory` and start! If the system fails you just restart. For persistence it just involves ensuring you're using queueing backend
*  **How do I integrate external application APIs and other tools ?** You will be writing Python modules. STS has the modular and scalable approach
*  **What should i configure if i'm getting `Timeout Errors?`?**   This indicates an operation or external task that has timed out! Check configuration for appropriate settings, and potentially add additional error logging to help debugging and fix
*   **What does scheduler. `start()`  mean and what will this do after I run the ` add_task()` call.** The function immediately scheduler the given tasks with the configured scheduling intervals!  If the scheduler already exists, running again just means the scheduler has been activated

## Citation

Whenever applicable please include in a paper as the source or framework that enabled you the functionality..  If using for any commercial applications it can cite as below for appropriate references
```bibtex
@software{sts,
 author = {The STS Contributors},
 year = {2024},
 title = {Simple Task Scheduler},
 url = {https://github.com/sts-contribs/sts-scheduler},
 version = {1.0},
 language = {Python},
 notes = {A task scheduling framework for python!}
}
```
You acknowledge by properly attributing this as source material

## Contact

Please feel free to reach out through GitHub or send email with issue reports and feedback! Incubating open discussions through community-lead discussions is highly appreciated, which improves the framework overall. Please submit issues with any questions.   You can join discussions on Discord for help and suggestions, as well
