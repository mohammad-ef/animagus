# Distributed Key-Value Database - "Krita"

This is a README documentation for the Krita project. Krita is a decentralized, horizontally scalable key-value database built to be resilient, performant and simple to use and integrate. Designed around a peer-to-peer ( P2P) architecture, Krita aims to offer reliable data storage across a distributed node network, providing a robust platform for applications requiring data durability and availability in a dynamic or uncertain infrastructure.

Kritaâ€™s core philosophy is "eventual consistency" with a focus on strong conflict resolution mechanisms, enabling applications to tolerate temporary discrepancies while guaranteeing data convergence over time. We have leveraged concepts found successful in distributed ledger technology, like Merkle trees, for efficient and tamper-proof validation of the data. This makes it a useful tool for blockchain applications, decentralized storage, or any system requiring a robust, distributed data layer.

Krita supports standard KV operations: get, put , delete, and supports range queries to allow for efficient data retrieval. The underlying P2P topology is dynamic, with nodes discovering each other and adapting to node joining and leaving. The data is replicated across multiple nodes to increase both availability and data durability. Our goal is to provide a foundation for developers to build reliable and scalable applications, leveraging the advantages of distributed systems.

## 1 Installation Instructions

Before installing, make sure you have a working Go ( >=1.20 ) environment. Krita is written in Go, utilizing its inherent concurrency and cross-platform compilation capabilities. This ensures a smooth and efficient deployment across a multitude of operating systems and environments.. 

The simplest approach is to download the pre-compiled binary from releases or build it from source. The binary can be downloaded by navigating to our project's release page, and choosing the appropriate version of the binary for your system. This is the recommended approach, as it reduces the build time.

Next, you' ll want to set up a directory for the Krita configuration files (e.g., `/etc/krita`).  This directory will hold node configuration, peer lists, and other essential settings for the database's operation..

Then clone the Krita repository into your local machine by utilizing Git. 
```bash
git clone https://github.com/your-organization/krita.git
cd krita
```

You need to install Go dependencies with this command, using the Go modules mechanism.  If dependencies aren `t managed via go modules and are installed using a package manager like `go vendor`, make sure it works correctly..
```bash
go mod download all
```

Building Krita is achieved using the built in Go command. Make sure that go path is properly configured for your operating system. The binary is outputed to the repository `s root. 
```bash
go build .
```

Now it will output to `./krita` and is now runnable and should have proper file metadata and permissions assigned to allow users on your environment.  Make sure you set executable permissions with command such as chmod on *nix environments, before running it.

Finally, configure a network port, for Krita, to operate. A standard network configuration can use ports above 1024 for avoiding permission or system access restrictions..
 

## 2 Usage Instructions

Krita offers both a command-line interface (CLI) and an HTTP API for data access. You will be interacting primarily via the command-line. For a list of the available Krita CLI flags you may pass it with `--help` or `-h`.

Start the Krita node using the built binary and configuring parameters, e.g. `--port 9000`.
```bash
./krita --port 9000
```
If there are multiple Krita nodes, then seed peer nodes with other addresses with `--peerlist 127.0.0.1:9000,127.0.0.1:9001`.
If not given peer nodes it defaults to singleton network which only has one member (itself).

The command line utility can be invoked for basic operation using a `put`, `get`, and `del`. For a given node the CLI commands `put key value` writes the value to disk, where get reads a key for that same instance, deleting will also perform the removal if it existed in the database

The basic operations will require an active server running for Krita and can utilize it's endpoint `http://localhost:9000/`.
Example of `PUT`: ```bash
curl -X PUT -d "value" http://localhost:9000/mykey
```

For getting data you may run with this `GET`
Example: ```bash
curl http://localhost:9000/mykey
```
Delete operation follows this format:
```bash
curl -X DELETE http://localhost:9000/mykey
```

To perform the operations over range it needs proper endpoint.  The implementation is planned in next releases, where the user should define `startKey` and `endKey` with proper formatting as JSON

Advanced functionality is supported via configuration using a JSON configuration files that can specify node ID, seed list, gossip interval, network timeouts. A default one should already have the configurations available and will require minor tuning before being production ready

## 3 Configuration

Krita's configuration is primarily handled through environment variables. You should be mindful of what these can represent since they are critical parts in ensuring the correct functioning.

`PORT`: Defines the network listen port. Default is 9000, and it's essential for network connectivity..

`NODE_ID`: Identifies this particular node.  Should be a globally unique alphanumeric ID, for helping differentiate different nodes from a global point-of-view. Default can represent an internal hash based upon IP, if not explicitly set..

The `--peerlist` can contain other nodes in order to allow discovery for the P2P mesh. This parameter takes on a CSV of IPs and Ports.  Proper network access for nodes in a different environment needs consideration and can have restrictions imposed by local system security settings..

Krita uses environment variables, instead of external JSON files because we wish to ensure a simplified, single point, configuration which avoids issues from managing files

For example a sample environment setup would look as below to properly allow peer list to exist

```bash
export NODE_ID=node-001
export PORT=9000
export PEERLIST=node-002:9001,node-003:9002
```

If there `s problems defining these through variables it is best practice to set it through parameters when starting

Optional configurations allow the tuning for parameters such as replication degree or the cantellation size to tune for different needs of performance

The replication level controls the data consistency by controlling a factor to control which copies get persisted.. 

## 4 Project Structure

The project repository structure follows a clear modular organization to support ease-of-development

```
krita/
    |- cmd/         # Contains command-line tools and executable
    |- config/      # Configurations file for the node, can define peers.
    |- internal/   # internal modules for various functions of this library.
    |- models/      # Models to hold the KV values that is persistent on disks
    |- peer/       # The core networking layer and discovery mechanisms for node to node connection.
    |- raft/   # the implementation based upon distributed ledger to ensure order and data durability, this component ensures the system maintains order when conflicts exist.
    |- tests/       # Automated integration/unit test to ensure stability in all operations and parts of components within Krita
    |- README.md   # This file you`re reading.
```
The `/cmd` folder will be used as main executable and entrypoint when calling ./krita on a *nix system.. The peer discovery uses this for its initial handshake

Models contain the data definitions that the nodes hold as Krita persists KV to disks This helps for persistence when network goes away as data does not go lost and will recover

`/tests` contain the different scenarios to simulate real usage.

## 5 Contributing

We welcome contributions from the community! Here is how you can contribute to the Krita project. Feel free to submit new issues.

To start contribute it first would require a proper clone with git
Make the necessary change. Follow existing standards with go style, formatting

Before submitting, create and update local unit/ integration testing

Open a pull request describing the feature you `re implementing, along with any context that needs attention from reviewers.. 

Review code style using linters before submission; We have implement standard go code standards in place. All code has be reviewed using linters to catch issues such code quality. Please run it to confirm that no new warnings exists before submitting to help improve development quality and reduce review effort..

All commits have meaningful descriptive content, which can assist other reviewers in their efforts, while understanding intentions for contribution, it reduces misunderstandings..

## 6 License

Krita is licensed under the **MIT License**. 

This license grants you broad rights to use, modify, and distribute the software, even for commercial purposes. The full license is found at MIT. The MIT license comes with no warranty, as the developer cannot control for any misuse

## 7 Acknowledgments

The Krita project has been significantly influenced by many resources, including. The core architecture concepts have derived from many P2P network design

*   **Raft:** We heavily borrowed implementation and principles for Raft. 
*   **go-kit:** We appreciate inspiration and practices of this library

This work has greatly contributed to making our development faster and efficient in terms of code readability as this feature helps in understanding code intent quickly for future enhancements..

## 8 System Architecture

Krita leverages a decentralized architecture to maintain consistency. Nodes in a network peer discovery with one another utilizing Gossip. Raft will orchestrate ordering, to prevent conflict

The data persistence and persistence occurs through keyvalue persistence. Nodes have data replicas, to maintain durability and consistency

Data flows across multiple node. A single write will propagate throughout nodes. Conflicts will get automatically sorted by raft

Krita leverages concurrency to achieve efficient processing. Go goroutines help process the concurrent read/writes..
Nodes have an HTTP and a P2P interfaces to communicate to one another or external services

## 9 API Reference

Currently Krita provides simple HTTP API for basic key-value store interactions

*   `/`: healthcheck to see current status

*   `/put/{key}`:  Accepts a PUT request for inserting the values in disk and network to replicate, it can receive POST request to persist it. Body needs key as string to allow persistence..

*   `/get/{key}`: returns `200 OK` with KV if existing; or error status `404`.

*   `/del/{key}`: delete key if exists on this particular Krita Instance
## 10 Testing

Unit/Integration testing is performed via Go test framework, which are under tests/.
Testing includes unit/integrated for each modules such network. 

Running these can simply execute this command `go test ./...` in command prompt in order to verify. Krita follows SOLID design and aims at testability

For Docker-ized environments we can test in containers to provide consistent testing without local configurations needed for the developer environment. To enable Dockerized env, you would execute
docker run kritabuild. 

We test against the P2P infrastructure by running a set of tests. It `s a critical requirement

## 11 Troubleshooting

Connectivity Issues between Node

Check network connectivity by verifying port forwarding if necessary and make sure firewalls does not exist between Krita Node

Confliciting Node IDs
Verify that Node-ID`s unique across Krita Nodes for proper proper discovery

Database corruption
Restore the backup artifacts. 

Ensure enough memory
Allocate resources in a production environment

## 12 Performance and Optimization

For large deployments one may consider the use of caching

Consider increasing replicas to help in the durability factor..
For production use you want ensure sufficient CPU and Disk IO resources are allocated, in order to help Krita

## 13 Security Considerations

Secure Network Communication via TLS is a best practice, but can add complexity, so consider for enterprise use-case and should be tested properly
Input Sanitisation should take the proper care, by verifying all data to minimize the vulnerabilities
Implement proper authentication for all endpoints, for proper validation before performing

## 14 Roadmap

The next steps on improving performance are as follows:

-  Implementing more granular range queries, which enables filtering for data retrieval in a more precise and performant method.

- Implement encryption
Implement support and proper monitoring
Refine testing coverage and ensure proper coverage.

## 15 FAQ (Frequently Asked Questions)

Why use an alternative KeyValue system. Krita has benefits to existing key value systems by using P2P architecture and can persist in environments with less control

Why use a eventual model over stronger? It can ensure the performance in an unreliabel setting by allowing for some degree of consistency, in environments of high change or instability 

Why the lack of features compared to other existing system:  The initial design of our product, aims to focus only core components and ensure reliability

## 16 Citation

Please cite Krita appropriately when referring to it in publications

```bibtex
@misc{krita_database,
    author = {Your Organization},
    title = {Krita: A Distributed Key-Value Database},
    year = {2024},
    url = {https://github.com/your-organization/krita}
}
```
Ensure citation to allow other users of our products can give recognition back

## 17 Contact

Please use [our github repository's issues board](https://github.com/your-organization/krita/issues)

Contact the development teams for any bugs
Contact community for suggestions on enhancements