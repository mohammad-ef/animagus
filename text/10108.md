# Distributed Key-Value Database - "Krita"

This README serves as a guide for installing, using, deploying, and developing Krita - a scalable and fault- tolerant distributed key-value data store. It aims to provide a comprehensive document, catering to diverse user levels from initial adopters to seasoned contributors. Krita offers a powerful alternative within environments that deal with substantial data volume needs, demanding rapid lookup performance, and requiring robust availability. It is suitable to handle a large variety load.

## 1. Description

Krita is a system that distributes key- value store operations across multiple machines to provide improved performance and increased capacity.  It supports simple get operations for keys, as well a put to insert or update key values.  It' is based on a peer-to-peer architecture with each node responsible for storing a portion of the data. Replication is employed to ensure data consistency and fault tolerance in the event of node failures.

The architecture employs a consistent hashing scheme for even data distribution. This scheme ensures that keys are assigned to nodes in a predictable and scalable fashion.  The system incorporates a consensus algorithm (RAFT) for coordination and leader election, maintaining system consistency across all nodes in response to changes.

Krita is designed for high availability. The peer nodes automatically detect and resolve failures via a voting mechanism. This enables Krita to continue serving requests even when some machines are unavailable, thus maximizing uptime for critical processes. Furthermore, a detailed health reporting system helps administrators monitor and manage the cluster.

The system is built using Go for high concurrency and efficient resource utilization.  Its modular design makes it extensible to incorporate new features or adapt to different requirements. The system is also well-documented, which makes it easy for developers to build on. The goal is to provide a foundation for scalable and resilient data management.  

Krita aims to address the limitations of traditional single-node databases and offer a more robust solution for modern, distributed environments. It's well-suited for applications demanding both data integrity and exceptional response times under demanding load scenarios.

## 2. Installation Instructions

Prerequisites include a machine (or several) with Go (version 1.20 or higher) installed, Git for cloning the repository, and optionally, Docker for simplified containerized deployments. A modern terminal with shell capabilities such as Bash or Zsh are expected for operation.  Basic command-line knowledge will improve user interaction and system troubleshooting ability. 

Clone the Krita repository from GitHub:
```bash
git clone https://github.com/your-username/krita-kv-store.git
cd krita-kv-store
```

Build the Krita binaries from source:
```bash
go build -o krita cmd/krita/main.go
```
This command compiles the `main.go` file within the `cmd/krita` directory into an executable named `krita`.  Make sure Go modules are initialized with `go mod init krita-kv-store` prior to build if they aren.t already present. 

For a quick demonstration on a single machine:
```bash
go run cmd/krita/main.go --port 8080 --datadir ./data
```
Adjust the port number and data directory to suit your preferences.  The specified data directory must exist with suitable write permissions for the process running under this context.

Setting up environment variables such as `KRITA_PORT` and `KRITA_DATA_DIR` enables configuration via system settings as an alternative approach for persistent configurations for ease. They will take priority over specified arguments. 

When running on multiple machines, configure each instance with a unique identifier (e.g., `--nodeid 1`, `--nodeid 2`). It is critical for proper node synchronization, that you set a specific port that doesn't conflict, and specify unique IDs across machines involved. Each node needs access to the internet.

If using Docker, ensure that you've installed Docker and Docker Compose. Refer to the `docker-compose.yml` example for containerization. Then to build images use,
```bash
docker-compose build
```

To run it:
```bash
docker-compose up
```

Note that Linux systems generally follow installation processes seamlessly and require little modification in command syntax compared to MacOS or Windows machines.  Docker on Windows might involve WSL setup and port forwarding adjustments in the host. Docker Desktop is a good way of handling that in an easier way. Users running the code under Windows, may experience compatibility issue and it may not always behave consistently when dealing with the operating system level permissions of directories used by Krita, especially during testing or deployment to cloud platforms.

## 3. Usage Instructions

Start Krita instances on multiple machines, providing a unique `--nodeid` to each. Ensure the port number used with `--port` doesn.t collide on different machines to guarantee correct network interaction for each individual process involved. Each Krita instance can then receive, serve, or replicate. 

Basic usage - Inserting Key-Value data, using HTTP requests from the terminal.

```bash
curl -X PUT http://localhost:8080/key1 -d "value1"
curl -X PUT http://localhost:8080/key2 -d "value2"
```

Fetching Values via HTTP, retrieving previously set entries
```bash
curl http://localhost:8080/key1
curl http://localhost:8080/key2
```

Advanced example - writing an automated load test. This load testing tool helps you test Krita with different numbers of data inserts in the cluster

```bash
go run cmd/loadtest/main.go --nodes 3 --numops 10000
```
Ensure the loadtest script correctly references node addresses or IDs.  

For cluster administration via an HTTP dashboard on localhost on specified port.

```bash
curl http://localhost:8080/status
```

For checking cluster node health

```bash
curl http://localhost:8080/health
```
This returns a json format describing the state of Krita instances running and connected. It's useful in scripting. 

You may want to set `KITA_DEBUG` as an environment variable when attempting advanced testing for enhanced logging of errors, warnings and other information for diagnostics of potential failure.
## 4. Configuration

Krita primarily leverages command-line arguments and environment variables for configuration; configuration files may be supported in the future releases. To alter default operation behavior for the system as a whole you need to change those accordingly.  It will ensure consistency among instances across your deployment environments.

The port the server listens on is set by the `--port` argument; setting default is `8080`. Setting port through system level settings via, say an `.env` or `/etc/environment` can enable a systemwide configuration for ease-of-deployment in the future, where configurations will apply on bootup to all new nodes joining a cluster

The node ID (uniquely identifies an instance) via argument, the node ID will be auto-detected as a number in increasing sequential orders starting at 1

`--datadir` parameter sets a storage data directory, and its persistence and failure handling depends upon your system settings of permissions on storage devices involved

You can configure log levels. Use argument `-v` for verbosity or `DEBUG`,`INFO`,`WARNING`,`ERROR` level to configure logs. This affects system observability. It will log system operations into log-based storage

Environment variable KRITA_CLUSTER_ADDRESS can specify location or set of existing locations to connect and interact to, which will influence cluster discovery mechanism when new cluster is forming or when joining

Krita uses internal timers controlled through environment variable such as KRITA_GC_INTERVAL for automated storage data cleanups to improve disk utilization for data. It may involve setting of memory thresholds as an optimization as well for resource control to prevent potential denial-of-service events. 

You can modify data storage size via argument --cache_size to specify cache allocation, it may affect system runtime.

To change number of worker go routines, specify number through setting argument. This has impact on performance, so careful evaluation needed prior changes to this setting

Advanced users will be importing configurations via external storage to persist across deployments for more complex setups with specific operational needs and scaling needs, but currently only via direct parameters on execution are enabled, so keep environment consistent across deployments as possible to simplify operational use and deployment. 

## 5. Project Structure

The repository structure for a clean project, to aid navigation and collaboration, it consists of distinct folders, where functionality of code modules can easily separated

`cmd/` contains executable application logic for running a Krita instances. 
`cmd/krita/main.go`: main entry point

`cmd/loadtest/main.go`: command for simulating data writes in load- testing

`configs/` (Currently not in use, planned location to host external settings) - configuration management. This location would be where you put configuration for future versions
`internal/` holds the internal core libraries of code that Krita instances will interact internally
`internal/db`: handles persistence and retrieval of keys-values

`internal/raft`: provides RAFT cluster coordination functionality for leader election

`internal/server`: HTTP endpoint implementation
`pkg/` contains code packages to be imported in different Krita code

`pkg/consensus`: implements a distributed system agreement algorithm abstraction. Provides interface. It may contain different algorithm choices, with Raft implemented currently 

`tests/` for comprehensive integration unit/performance and acceptance of different code paths for quality

The directory layout helps modular development and maintenance of code modules across Krita instances and future development enhancements to be easily deployed. A modularity enables teams of software engineer for better coordination

## 6. Contributing

We encourage active community contributions and appreciate support from others to help evolve the project to improve and enhance quality to make this system as great as it could

Report bugs and enhancement via opening a dedicated ticket issue on github, please contain steps-reproducing error in issue and detailed system specifications to ensure the best support
Fork Krita code from this repo on GitHub
Clone the source to a directory and run commands such as
```bash
git pull
git checkout -b <name-new-feature>
go build  //Build project for development.
go test
```
Make the desired enhancements, add or update test code, then open Pull request from local repository
Code must follow coding conventions as described at coding conventions. Go standard library and best coding guidelines.
Test code is crucial, unit, system level regression testing and functional end-to-end must pass.

## 7. License

Krita is licensed under the Apache License 2.0. The project allows commercial, scientific, and open use cases of it under a few constraints.  Users can copy, modify, and distribute source codes without needing any attribution and commercialize without limitations to enhance system and build upon the project, provided proper license acknowledgement of original project.
See the LICENSE file. 

## 8. Acknowledgments

The developers express deep gratitude for Go and all libraries for their robust nature to build on for attack and scalability for data. The Krita design incorporates many lessons drawn from Apache ZooKeeper for reliable fault tolerance and clustering of processes

In addition to libraries for Go development the developers thanks open community of Kubernetes as an inspiring example

This is also in gratitude to those in online forums who have answered many technical inquiries that had contributed.  
We recognize those on stack exchange forums who had provided helpful advice on cluster networking. The developers thank open contributors in the go community

## 9. System Architecture

Krita uses a peer-to-peer architecture composed of multiple Krita nodes. These peers work with one another and maintain consensus for the key value storage to function

Each node maintains key values within storage, but the distribution and management is managed. This helps provide redundancy to the system
The architecture leverages consistent hashing that evenly distribute storage keys among peers to prevent a central node for managing system

Consensus algorithms are crucial such as RAFT to elect the leaders. This helps in coordinating the writes to system

HTTP protocol provides simple REST interface, where users or client-applications access to network to interact the Krita system

A cluster health manager tracks health of all members for system observability for quick resolution on potential node failure and performance tuning, which provides insight of operations on data-stores involved 
The modular and scalable framework allows the integration and extension in new components and capabilities easily.

## 10. API Reference

Krita supports following REST operations, where the endpoints listen at `/key`:
PUT /key <value>
  Store value for a given key, creating an item on server and making available for reads and subsequent interactions on the store, where data can easily managed and replicated 
GET /key
Retrieve stored key. This retrieves previously inserted entry in server storage
DELETE /key
Removing a key in server to make available and to release its corresponding resource in cluster storage

HTTP responses codes are standard with successful operations responding a HTTP/200 response code while unsuccessful sends HTTP error code
## 11. Testing

Unit, integration, and load tests exist, they provide an important means and method on assessing performance. They ensure code correctness on system, where tests help improve stability to drive adoption in real environment scenarios. To run test suite

```bash
go test ./...
```
Unit and loadtest code exists as independent packages in test directories
For functional and acceptance test suites run:
```bash
./run-acceptance-test.sh
```
## 12. Troubleshooting

Connection refused to server, often mean the service hasn;t initialized, or the firewall blocks traffic on default network. Check the service is properly launched with correct settings
Key Not Found: The specific data key has yet not added or has since been cleaned up. Key value pair is either missing or deleted and requires to recreate the value pair to retrieve. 
Data is not consistent - this typically is result in misconfiguration, cluster sync failing - review node settings for compatibility or connection and review configuration. 

## 13. Performance and Optimization

Krita leverages in memory and caching strategies on nodes. This allows read operations to become faster
Go routines can be utilized for improved throughput, concurrency in system
Consistent Hashing enables fast access keys for storage in cluster, avoiding centralized index for quick retrieval

Memory caching is configured for improved data look-up times, where settings and sizes are fine tune-able in configurations and settings for best results in performance. It avoids repetitive data fetching. The memory utilization of nodes should carefully tracked for best results for system health
## 14. Security Considerations

All sensitive values must never exposed to clients or other applications without security validation

Inputs validated carefully and data is not sanitized, it is potential source in vulnerability, therefore must sanitize user inputted parameters prior writing into data
All data should encrypt for storage for confidentiality and integrity; Krita currently supports basic level but should encrypt with robust algorithm for real world deployments. Use strong algorithms to enhance overall security and protection.

Secrets stored outside in key vaults for enhanced better system protection; storing sensitive keys into environment settings should not occur due to exposure

Apply and keep up to-date with regular system updates

## 15. Roadmap

Enhance storage backend, adding persistence support via databases.

Adding multi factor support, to enable secure multi layer user- access approval to ensure protection on system. Authentication of Krita clients is scoped in future plans for better user-protection. 

Develop advanced querying capability and filtering. Currently the store support get operations. In near term will be filtering support and querying capability for complex retrieval of system values to better serve needs

Support new consensus, Raft currently employed, other choices may improve efficiency

Integrate more sophisticated logging and alerting to aid with proactive issue diagnosis in operations to improve reliability for production deployments. 

## 16. FAQ (Frequently Asked Questions)

"My node won"t join the cluster": Make sure each peer in peer nodes have different NodeIDs assigned to guarantee system can identify nodes correctly in peer networks
Why do the cluster members keep getting reset": Review node specific and system configuration. Check if network is accessible to nodes to guarantee proper cluster health for consistent operation, and also ensure cluster is properly provisioned on system 
## 17. Citation

If utilizing the work and Krita as foundation or inspiration, please reference this work appropriately, and we welcome to share any work and contribution.  This encourages the collaboration.
BibTeX format below,
```bibtex
@software{krita,
  author = {Your Organization/Team},
  title = {Krita - Distributed Key-Value Database},
  url = {https://github.com/your-username/krita-kv-store},
  year = {2024},
  version = {1.0.0}
}
```

## 18. Contact

For feedback report any detected bugs, and any suggestions please submit through github issue tracker and create issues

Email contact for technical assistance: kritasupport@example.com,
Community forum on Stack Overflow tagged [krita-kv](https://stackoverflow.com/questions/tagged/krita-kv),



