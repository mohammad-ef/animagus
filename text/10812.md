# Distributed Key-Value Database - "Krita"

This README serves as a guide for installing, using, contributing to, and understanding the Krita distributed key-value data store. Krita aims to provide high availability, fault tolerance, and scalability for storing persistent data.  It achieves this with a gossip protocol, Raft consensus for updates, and a sharded architecture. Krita is suitable for scenarios requiring high reliability like financial transactions.

## Description ##

Krita is built to be a reliable and scalable key-value storage system.  Data is partitioned across nodes using consistent hashing, ensuring efficient distribution. Each shard replicates data across three nodes for redundancy. Node discovery is achieved using the decentralized gossip protocol.  The database is primarily written in Rust with some bindings to Python for easy use. Krita offers a command- line interface and a REST API for managing your database.

The system utilizes a Raft consensus engine for ensuring all shard replicas are kept synchronized when updates are received.  This guarantees consistency across the distributed storage.  A client library simplifies integration with various applications by offering simple key- value store operations with automatic failover. The architecture is designed for horizontal scalability to meet future needs.

Security is a critical consideration.  All communication is encrypted by TLS. Access controls based on roles are also built in. The data model is simple: a key- value storage. The keys and corresponding values are serialized with Protocol Buffers to minimize space usage. Future versions will include support for other serialization formats.

Krita is designed with operational simplicity in mind.  Automatic node recovery and rebalancing are built in. Detailed metrics are logged for monitoring purposes using Prometheus.  The command- line interface facilitates common tasks like creating, deleting, and querying clusters. This reduces operational overhead.

The project emphasizes modularity and testability. The architecture is broken down into small, independent modules that can be unit tested easily. Integration tests ensure system functionality under complex load conditions. A continuous integration process guarantees stability of releases. Future releases include enhanced metrics and a graphical admin console.

## Installation Instructions ##

Before proceeding, ensure you have Rust, Cargo, and a suitable C++ compiler installed. These may already be installed depending on your system configuration. We require at least Rust version 1.65 and above. It also relies on the gRPC protocol and must be properly installed. This ensures inter-process communication.

To build Krita, first clone the repository:

```bash
git clone https://github.com/your-organization/krita.git
cd krita
```

Then build the system using cargo build, making sure cargo-grpc is properly set up:

```bash
cargo build
```

On Linux systems, you might need to install build dependencies for the Protocol buffer. This step helps the compiler link to all system-level tools that support protocol bufffers.

```bash
sudo apt update
sudo apt install protobuf-compiler libgrpc++-dev
```

On macOS using Homebrew:

```bash
brew install protobuf
brew install gRPC
```

Windows users will need to install similar development packages with either MinGW or Visual Studio Build Tools. Check cargo and ensure the gRPC dependencies exist on the Windows platform.  Ensure environment variables related to Rust, Cargo, and build tools are set.

Next you have to setup a local database with some example data which you will be interacting with using a few CLI examples later on. Run the following cargo build and then example commands for initialization. This step ensures all local configurations have properly taken effect.

```bash
cargo run --bin init
```

Now you need to run Krita, ensuring a configuration file has been provided to ensure all network configurations and data locations are setup:

```bash
cargo run --bin kritad
```

After starting Krita in server mode, install and setup necessary libraries on other clients or your own workstation if testing:

```bash
pip install kritaclient
```

This ensures all dependencies on python clients or scripts is properly taken care of to allow interaction with kritad servers on various platforms and systems.  It also provides access to API documentation to guide integration into multiple platforms.

After successful completion of setup ensure that kritad service is accessible and running properly using netstat and port monitoring services available. This allows verification if there is an error.  Also monitor resource utilization such as memory consumption and network usage to avoid performance pitfalls in large distributed networks.

To enable debug and detailed logging install `RUST_LOG=debug cargo run`

Ensure your Rust tooling version matches or greater to avoid conflicts during deployment of kritad on large distributed infrastructures and systems. This is important as Rust updates rapidly with bug fixes and improvements

After a complete install check that Krita is operational via a CLI client, and all nodes have been initialized. A complete system will include at least three Krita cluster members and all configurations should be synchronized

The `Cargo.toml` files will have version and platform specific configurations in order to allow developers easy build management across systems. Ensure proper version pinning to minimize dependency errors across environments.

You need at least two to three cluster servers and each of these services should point to its neighbor's configuration for the gossiping mechanism.

You should run tests and ensure that there is sufficient storage for the initial setup as this impacts scalability

Finally check to verify all the cluster nodes properly sync data to ensure a complete and functioning data storage network.



## Usage Instructions ##

Krita's CLI client (provided through `kritaclient`) can be used for most interactions. After running Kritad on each respective node connect your clients as shown. Ensure proper authentication keys or protocols have been configured and set properly.  This prevents unwanted or un-authorized access to sensitive systems

```
kritaclient --host <host> --port <port> --cluster-name <cluster_name> --token <your token> put <key> <value>
```

You can query existing keys via command like:

```
kritaclient --host <host> --port <port> --cluster-name <cluster_name> get <key>
```

You may wish to delete keys with a command as follows :

```
kritaclient --host <host> --port <port> --cluster-name <cluster_name> delete <key>
```

You can perform list keys operations via CLI, allowing users a perspective on keys stored :

```
kritaclient --host <host> --port <port> --cluster-name <cluster_name> list-keys
```

For cluster health you should execute cluster check and health check:

```
kritaclient --host <host> --port <port> --cluster-name <cluster_name> health-check --all
```

Using Python libraries and bindings can perform advanced tasks and scripting. Import `kritaclient`, instantiate with appropriate configurations, use simplified client interface:

```python
from kritaclient import KritaClient

client = KritaClient(host='localhost', port=8080, cluster_name='mycluster')
client.put('testkey', 'testvalue')
value = client.get('testkey')
print(value)
```

This can allow programmatic control to interact, manage data with ease for automation or other applications,

Use API endpoints (accessible on localhost port 8080) to access cluster status information. The /healthz will indicate health check of each member in your Krita clusters, enabling real time insights

Advanced users can also use `cargo build --release` in release to create a production binary optimized in addition to the default builds in order to achieve the desired production readiness levels for scaling across environments

Consider writing integration and functional tests as needed, allowing users full automation capabilities in order to manage deployment pipelines across systems to avoid configuration drift issues in complex production systems

To improve the efficiency when writing and fetching from large keys utilize batching mechanisms and multi-threading techniques

## Configuration ##

The configuration is primarily handled through YAML files (`krita.yaml`).  This file defines things such as cluster names, node IDs, peer addresses for gossip protocol. A `data_directory` key indicates persistent key value stores. Default port number of server 8080 needs be set. A default log path is available

For instance a typical krita configuration will have a cluster and data location set :

```yaml
cluster_name: "mycluster"
node_id: "node1"
peers:
  - address: "127.0.0.1:8080"
  - address: "127.0.0.1:8081"
  - address: "127.0.0.1:8082"
data_directory: "/var/lib/krita"
port: 8080
```

Environment variables also control the cluster configuration if a config is passed or if there exists an error. `KRITA_CLUSTER_NAME` dictates what your cluster configuration. It's recommended to keep cluster name consistent, but flexible enough so that users or operators will still understand it across different platforms

Use `KRITA_DATA_DIRECTORY` environment variable, if a directory path cannot be located or if an exception occurred in krita YAML config files or during deployment stages

Port is configurable through  `KRITA_PORT` for cases requiring specific or customized configurations to allow different clusters to work alongside each other

The system also uses TLS configuration with `KRITA_TLS_CERT_PATH` path that contains the certificate files needed

Dynamic reconfigurations happen automatically, allowing cluster configuration on fly and without restarting servers. These configuration management can greatly help operators to avoid manual interventions

If using authentication token for secure interactions configure the system via: `KRITA_TOKEN`, this is required for production use-cases and is extremely important in securing systems. Authentication mechanisms allow for a multi tiered security architecture that can support large scale distributed infrastructure.

Ensure to validate all configs for clusters as well.

The number of nodes per shard are dynamically allocated depending on server health or availability metrics from Prometheus. Ensure all metrics monitoring and health metrics properly integrated and running correctly.

Configuration files are loaded and cached at runtime by Kritad server and clients. Invalid config changes should immediately return to previous states. Ensure the right configuration changes can happen.

For cluster members use different configurations so it can dynamically adjust based on load, health or performance. Ensure proper cluster clusters for different deployment stages, and production workloads.

You are free to create a config and deploy to multiple instances in production for ease-of-use and to simplify scaling across large production networks.




## Project Structure ##

The repository structure reflects modular design:

```
krita/
|-- src/
|   |-- core/            # Core database logic, storage and Raft consensus engine
|   |-- network/        # Gossip protocol and peer communication
|   |-- client/          # Client libraries in Rust
|   |-- api/           # API for accessing cluster management operations
|   |   `-- mod.rs      # Public module API.
|-- kritaclient/     # Rust library and bindings used
|   | -- lib.rs       # Library and bindings entry points.
|-- tests/           # Unit, integration, and e2e tests
|   |-- core/          # tests focused on `core/` modules
|-- krita.yaml         # Main cluster config file
|-- Cargo.toml        # Dependency Management, configuration for rust
|-- README.md         # The documentation for the Krita distributed KV.
```

The `src/core` folder holds crucial logic related to persistence management.  It also implements all storage, serialization. The data is persisted on file. `src/network` manages node interactions via peer-to-peer messaging with Protocol Buffer messages

`kritaclient` folder houses clients libraries. Rust clients, which is the primary entrypoints, and client libraries written python. These client allows interaction, read data with ease

Tests directory contain different levels and types of validations and unit testing. They ensure cluster members work seamlessly in distributed systems with different configurations and workloads. The cluster health check also depends on these

All build files will be defined under the `Cargo.toml` and it defines build requirements. All the crates can build together. Dependencies of crates, Rust tool version.  

Ensure all dependencies listed in Cargo.toml is available for developers, or the builds wonot run

You will find build configuration information as you move into higher production.



## Contributing ##

We welcome contributions to Krita! Before you get started, please review our contribution guidelines. This includes formatting style and testing standards, which help us guarantee that contributions can be incorporated without disrupting ongoing maintenance activities. This will help developers understand the project.

If you discover a bug, report it via the issue tracker on GitHub: [GitHub issue tracker link](https://github.com/your-organization/krita/issues). A proper explanation or details of what triggered bugs help the team to debug more easily.

Pull requests should conform with code standard style guidelines to avoid merge- conflicts when integrating into the system and avoid errors among developers when integrating with it. We also appreciate contributions to our documentation; if we missed any critical information, or have mistakes let's improve documentation as part of community engagement efforts. Testing of new features or changes needs be ready to integrate and run in production, before they are considered for deployment.  All pull requests have to be properly unit- tested before they can merge, in our system! Ensure there isn't an impact or change that can cause instability across production deployments and configurations.

We also adopt `gitflow` branching models which means feature or hotfix branch need create a branch, make code improvements/fixes before submitting PR back for review before integration

If possible submit code improvements or features using feature-based PR to minimize risks

Ensure all commits include detailed explanation for what code was changed and reason to change for code traceability, to improve developer maintainability

Follow the style guidelines defined with clippy to avoid warnings on rust projects for cleaner coding standard for production deployments

All pull requests should go into `dev` branches

For larger contributions discuss your plan first via GitHub Issues so everyone involved knows of changes

All commits needs tests to ensure changes aren't detrimental.




## License ##

Krita is licensed under the **MIT License**. This provides information regarding licensing, usage and how this is to be distributed across multiple users or environments. 

You are free to use, modify, and distribute Krita, both commercially and non-commercially. Attribution to the original authors is appreciated but not legally required. The use case must follow the terms.




## Acknowledgments ##

We would like to acknowledge the following libraries and resources that made Krita possible:

*   **Rust:** For its memory safety, concurrency features, and excellent tooling. It makes it an efficient system in building distributed applications across environments. It ensures the safety of all code deployments for a higher degree of stability

*   **gRPC:** This enables high-performance inter-process communication, and allows multiple cluster members.

*   **Protocol Buffers:** This facilitates serializing the system in the form that enables easy transmission of cluster information to enable efficient and high throughput

*   **Raft Implementation**: Our inspiration came from the original Raft consensus paper, by Eric Brewer et al., a fundamental resource of how to develop distributed data systems for production. The implementation was adapted to fit within a system like krita for scalability, security and ease to maintain over long operational periods.



## System Architecture ##

Krita is designed as a sharded, distributed key-value store with the goal of reliability and performance:

1.  **Sharding**: Keys are partitioned among nodes via consistent hashing for balanced load distribution and improved query speed, reducing load. Each member handles its shard of workload for scalability across production environments.
2.  **Replication**:  Each shard is replicated across a trio of nodes for enhanced durability; even during failure events there still exist at least two shards that can provide availability for a service level availability (SLA) goal. Data availability across failures and node replays is extremely essential in building fault tolerance
3.  **Gossip Protocol**: Node discovery and heartbeats happen by peer communication with Gossip. A cluster knows about the members through constant monitoring and peer exchange for fault-awareness. This enables a system-aware self managing cluster
4.  **Raft Consensus**: Configurations are made using RAFT Consensus to achieve consistency, especially regarding the update sequence for shard data, which is extremely necessary
5.  **API Server**:  Clients access the database using gRPC endpoints for efficient request execution on all shards across different cluster member deployments and integrations with multiple environments

Krita employs a combination of techniques, and a micro service design with independent and autonomous shards providing horizontal scalibility. Each service and module has well defined APIs with a modular and maintainable infrastructure, which can scale efficiently in complex enterprise and data center systems

This architecture enables efficient, and fault tolerant operation for critical production data stores




## API Reference ##

The primary interface to Krita is its gRPC API:

*   **Put(key, value)**: Stores a key-value pair in the shard, and replicates data among replicas
*   **Get(key)**: Retrieves the value associated with a given key; reads across all replicas of the relevant data shards. If a read fails return the cached replica of a shard and make an error report to the operator of kritad cluster, so issues will resolve quickly
*   **Delete(key)**: Removes a key-value pair and updates the shards to reflect changes. Deletes are replicated through raft and can trigger cascading delete across systems to improve efficiency

The REST API exposes a basic subset for health probes or status checks for cluster management, such as `cluster healthcheck/` and metrics ` /healthcheck`: These will give visibility for system administrators and DevOps personnel

Detailed protobuf definition are found on GitHub repository to help understand how different cluster messages and interactions take shape in distributed environment
All API interactions should use authentication with `token: ` key

All APIs return standardized codes, which include errors to enable effective integrations into production




## Testing ##

Testing plays a critical role for stability of this project, so a complete set of automated unit, integration, and performance/benchmark suite will need complete. Unit tests are found within core components in order to ensure they work in various cases of inputs
Ensure integration is also performed with different client tools

Cargo Handles all dependencies to manage different tests and run configurations, allowing ease testing

You run testing suite via cargo tests
cargo test to test each core functionality for stability and consistency, and correctness.
You run the integration suites, you need setup an instance to ensure that multiple components work correctly, to guarantee that there is integration and no regressions

## Troubleshooting ##

1.  **Node connectivity**: Nodes can have intermittent connection issue if the cluster configuration has issues in DNS and/or Firewall settings
    Fix it by reconfiguring and making cluster nodes visible, or checking cluster DNS. This allows for better monitoring and troubleshooting in complex deployment

2.  **Dependency versions**: Conflicts often occurs with mismatched Rust or dependency.  Make sure all dependency matches or at the very least the major version
     Fix by running build from cargo build or updating the `Cargo.toml` and run `cargo build` in clean slate mode

3.  **Raft election problems**: Election fails when too many nodes have simultaneous network problems: Increase time out values in cluster configuration, or check cluster network connectivity between nodes
   Resolve this issues via configuration tuning of time intervals or adding better connectivity in environments
   If this persist consider re configuring all clusters in order to avoid network partitions



## Performance and Optimization ##

Optimize by using faster serialization with efficient serialization format and protocol buffs: Krita already using them but we are continuously working for optimizations
Utilize efficient memory storage techniques such as object pooling

Optimize query efficiency using indexing, but it's a potential cost tradeoff.  We may want add more advanced query options

Improve inter process commmunication using zero copy to increase throughput, to reduce unnecessary copying
Consider asynchronous request handling and batch operation

Implement more robust monitoring using Grafana and alert for any critical thresholds



## Security Considerations ##

Enforce role-based access with TLS, so it is extremely critical to properly secure Krita deployment to mitigate against data breach. Always encrypt TLS connections
Proper key-rotation strategy and regularly scan configurations with code review

Implement secure coding principles like validation on data inputs
Use authentication token

Report vulnerability either to maintainer directly. Regular patching and upgrades should happen.




## Roadmap ##

*   **[ ]** Admin UI for monitoring, configuation (v1.2)
*   **[ ]** Add Support other data serializers such as JSON
*   **[ ]** Improved cluster rebalance mechanism. Automated sharding based on cluster node (v1.3)
*   **[ ]** Advanced Query Capabilities for faster searching of specific records.



## FAQ ##

1.  **How can configure nodes dynamically:** Node membership can change in the krita cluster via gossip or using configuration update

2.  **Which protocol are you using** We are use gRPC protocol as primary means communication and Protocol buffer

3.  **Are the shards auto-balancing?:**  The clusters automatically attempts shard balacing to improve load, so there's minimal configuration for cluster management




## Citation ##

We welcome academic and/or commercial usage of this project and want the community engaged, we would want a full proper attribution if this project used:

```bibtex
@software{KritaDatabase,
  author = {Your Name/Organization},
  title = {Krita: A Distributed Key-Value Database},
  year = {2024},
  url = {https://github.com/your-organization/krita}
}
```

We expect that citations should mention our contribution and how this project is used

We welcome suggestions on what should we modify as part of improving and growing kritad. Thank you.




## Contact ##

You can reach the project maintainers via Github. Issues and PR can submit on issues, but if urgent reach them on the community email.
Email support available, as needed at `your.email` or `github issues page ` for support related. We have also established slack channels to allow faster response and support across different platforms