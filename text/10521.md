# Task Management Engine - "Tempo"

**Tempo** is a task and productivity management engine designed to enhance project workflows with robust scheduling, resource allocation, real-time progress tracking, and insightful analytical reports. Built with the modern professional in mind, Tempo helps teams of all sizes maintain organization and achieve goals efficiently. Its adaptable architecture allows it to seamlessly fit existing workflows, improving visibility without disrupting established routines. 
    
## Description

Our aim is to create a tool addressing the shortcomings of traditional task lists. Tempo moves away from the simplistic "to be completed" approach, emphasizing a granular, time-centric breakdown, with clear resource association and proactive dependency identification features.  We provide a centralized, easily accessible platform for project management. 

The software utilizes the Reactive framework, built atop a Rust core, providing a reactive and efficient data model, while leveraging modern asynchronous techniques, and a Postgres backend for data persistence. Tempoâ€™s core functionality encompasses creating tasks, associating them with project deadlines, specifying responsible resources and their associated workload, as also, tracking progress via a detailed progress tracking module.

Real- time reporting dashboards, powered by a combination of data visualization technologies, will provide a snapshot of the project state. This will allow managers and team leads to immediately spot potential roadblocks, re- allocate resources, or re- prioritize tasks for a quicker delivery. Tempo strives towards proactive management, allowing early intervention on problems, instead of reacting to issues as it arises in a traditional approach.

Furthermore Tempo supports a robust API, providing external applications with the ability to create new tasks, access data, integrate into existing ecosystems, such as CI/ CD, project planning, and collaboration applications.  Security is a top-level priority for Tempo, implementing comprehensive authorization, role-based access and audit trails in order to prevent unauthorized access and data tampering.

The design is centered on a highly customizable dashboard that caters to different user types, allowing developers to see the progress of assigned tickets, while managers get a holistic overview including team capacity utilization, resource distribution, and critical path bottlenecks. Finally, the architecture supports scalability, with an aim to easily handle increasing workloads and a growing user base without compromising performance or data integrity as the system gets larger. 

## Installation Instructions

Before attempting the setup, make sure you install a compatible Postgres instance. Docker is also a highly suggested way to get Tempo set up quickly. We provide a container based solution to avoid the complexity that may appear during the local dependencies installation.

First, clone the repository from your preferred Git client into a directory that will contain the Tempo application installation directory. Then, navigate into it. This directory will be referred to as `<tempo_home>` in the remainder of the document.

```bash 
git clone https://github.com/[repo_url - replaced here] <tempo_home>
cd <tempo home>
```

To install dependencies, run the `cargo` build tool: This process may take 1 minute or more depending on machine performance and existing toolchain. This ensures that the Rust dependencies are installed. If using Cargo, ensure the `rust toolchain` is also installed.

 ```bash
cargo build --release
```

For Linux environments, make your binary executable. If not using Docker, it might be necessary to copy the compiled binary into a location within a PATH variable for it to be called from terminal.

```bash
chmod +x target/release/tempo
```

Configure environment variables to ensure that Postgres is correctly accessible. `DATABASE_URL` is mandatory, and contains the connection string that the application will be using to interface with the Postgres instance.

```.env
DATABASE_URL = "postgres://user:password@host:port/" # Update the values
```  

If the `DATABASE_URL is not specified`, the app will fail with a Postgres connection error, which will prevent the application from starting correctly. The Postgres schema and users can be generated from the `sql scripts` folder. This should be the very first database action.

To install the client side, using `npm install`: This step can be performed within any of the client directory that includes `package. json`, such as the `src/client` folders. This will download and setup all necessary dependencies needed for a correct execution for both the UI and tooling.

```bash
cd src/client
npm install

```
For MacOS, you might need Homebrew installed, to install dependencies such `node` and `npm`; `brew update && brew install node`. For Windows, download the installation package from the [official NodeJS website - replaced here] and follow the steps in the install process.

## Usage Instructions

To start the server, using Cargo, in the directory you downloaded the code you should run the next command. This process compiles the code for a production build. This command will also initialize the Postgres database and generate any missing tables if not found previously during the schema migration.

  ```terminal
cargo run
  ```

The API endpoints, are documented using `Swagger`, a standardized approach for defining APIs, with interactive UI that can test the endpoints, and visualize the request & response schema. This will be available by navigating your browser to ` http://localhost:8080/openapi`. It is highly recommended to explore the API before interacting, to familiarize with how the system functions internally as a developer.

To add tasks, utilize the `POST /tasks ` endpoint, passing a JSON payload with relevant task details ( `title`, ` description `, ` due date` and ` assignee` ) . This will generate an appropriate `response`, that indicates success. 

To query a list of tasks, utilize the endpoint `GET /tasks`. To query tasks of a particular user, use  `GET /users/{id}/tasks `, passing the relevant user ID, to filter the results. To get the current user information, utilize `/ users/ me`, with a `GET HTTP` request. 

To get all resources assigned, with available workload capacity, call endpoint `/workload`, which will return the workload for each employee assigned. The `workload` endpoint can be called on a per- user basis, utilizing `/workload/{user_id}`

## Configuration

Tempo can be configured via a combination of environment variables, configuration files located under `< tempo_path>/ configs/`, or a command line flag. Environment variables take precedence over values found in the configurations folder.

 The `DATABASE_URL ` is essential, as previously discussed, but other optional variables exist, controlling the behavior during production, such as `LOG_LEVEL` to configure the amount of verbosity, or `API_PORT`, to change the port. These will affect the operation during the lifetime of the application. 

The configuration files, typically in YAML format, can be located under the ` <tempo_path>/ configurations` directory to further customize the system beyond what's supported by the environment variables. It is recommended to use environment vars as a preferred approach over configuration file modifications due to ease of management across the environments during CI/ CD pipelines and other deployment procedures for a production build. The ` application. yaml ` file is a good start.  

You can override any configuration setting from the command line, by adding `-- <key>=<value >`, such as `--api-port ` to specify a new port to be opened by the server, in contrast to the environment vars and configurations.

##  Project Structure

- `src/`: Contains the main source code, with the Rust core logic and the reactive engine.
  - `client/`:  Contains the client application. Built in `VueJS `, and using Typescript for a cleaner and safer development experience.
  - `core/`: Contains essential application logic, database interaction and task processing.
   - `models/`: Defines the data models that the application uses.  
- `config/`: Contains application settings.
- `scripts/`: Contains utilities for deployment.
      

## Contributing

We welcome contributions to Tempo! Please open an issue if you've noticed a bug and need help or have a new feature proposal. 

To contribute code, fork the repository and create a branch. Please adhere to the coding style outlined in the `.cargo-fmt.toml ` file to keep the codebase consistent, as the application uses it to reformat the code automatically. All pull requests must pass a full build suite, using the `cargo test`, which validates the code for proper functioning.  

All contributors are encouraged to create a detailed test for their code, in the `tests/` directory. A well-tested change is easier to review, and more likely to be merged without regressions, and is a required condition before merging into master.  

 ## License

Tempo is licensed under a [ MIT ] license. You are free to use, copy, modify, merge and distribute this software, provided that you maintain the copyright, and include a copy of this license file within the product, and the original copyright. Any commercial usage is explicitly allowed, as long as these conditions are met.

## Acknowledgments

This project has been inspired by and leverages various open-source tools and libraries. We are especially grateful to the Rust community for building such a powerful and productive programming ecosystem, and also, to the Postgres project, providing a stable, feature-rich, data persistence option with a large community.  

## System Architecture

Tempo uses a three-tier architecture: a reactive web frontend, a REST API backend built with Rust, and a Postgres database backend. The frontend, built with VueJS, communicates with the REST API via `HTTP requests`, to manage application state, and to display the tasks, users and resources. 

The REST API handles user authentication, task creation, resource assignment and data querying from Postgres database. Data access is managed using an ORM to prevent security concerns, and provide a consistent interaction. The Postgres database persists the application' data including the user accounts, task details and resource allocation. 

## API Reference

**`POST /tasks`**: Create a new task.

*   **Params (JSON Request Body):** `title` (string, required), `description` (string, optional), `dueDate` (date, optional), `assigneeId` (integer, optional)
*   **Response (JSON Body):** `{id: integer, title: string, description:string, dueDate: date }`
*   **Authentication :** Required

**`GET /tasks`** : List all tasks in the project.

*   **Params :** None
        
*   **Response :** `[ { task data }, {task data } ]` - A list of tasks. 
*   **Authentication :** Required

**`GET /users/{id}/tasks`**: List all the tasks assigned to user id.

*   **Params :** `id` (required, integer)

##   Testing

To run the unit tests, execute the following in the ` < tempo_path>` from terminal. The test suite covers the core functionalities, ensuring the correct behavior.  

```bash
cargo test
```  

We use `cargo`, Rust built-in package manager, to manage all dependencies. A comprehensive set of `integration test` is available within the `integration/` folder, testing the end- to-end functionality, such as task creation, assignment and reporting features.  

## Troubleshooting

*   **"Connection refused" error with Postgres:** Double-check the `DATABASE_URL ` and verify that the PostgreSQL server is running, along with the correct credentials. Ensure your firewall is not blocking the port.
*   **Slow API response times:** Investigate database indexes or slow queries. Optimize the data model to improve the query performance, or increase hardware.
*   **UI rendering issues :** Clear the browser cache, update the browser, or reinstall the ` npm install` dependencies.

## Performance and Optimization 

We have implemented caching mechanism to minimize database queries for commonly accessed data using `Redis`, a memory based key- value store. This can be further improved by implementing `sharding` to distribute the data across multiple Postgres nodes, which will allow for a horizontal scale, and a high data load, without affecting application performance.

## Security Considerations

Ensure to store secrets and sensitive information like the ` DATABASE_URL ` in `environment variables`, and never within your source code for increased security. Implement a robust input validation, to mitigate the risks of security vulnerabilities, like `SQL injections`, or `Cross-Site Scripting attacks` (XSS attacks). Always patch and update dependencies with the latest version to stay protected by known vulnerability exploits, which can potentially compromise the system.

## Roadmap

*   [ ] Improved resource scheduling and conflict resolution.
*   [ ] Gantt charts for visual task dependencies.
*   [ ] Email/Slack integration for task notifications.
*    [ ] Advanced Reporting features.
*   [ ] Mobile support.

## FAQ (Frequently Asked Questions)

*   **How do I change the database port? ** Modify the `DATABASE_URL ` environment variable, ensuring to use the updated port when initializing your connection with Postgres. 
*   **How can I install this locally without using Docker?**  Clone this repository and make sure your dependencies like Cargo are available to you. 
*   **I cannot start up tempo and receive Postgres authentication failure**. This typically comes due to the password specified, ensure the user specified is able to correctly authenticate in Postgres instance you created, otherwise Tempo may refuse the access attempt to connect to your postgres DB

## Citation

```bibtex
@software{TempoTaskManagement,
  author = {Your Name(s)},
  title = {Tempo: A Task Management Engine},
  year = {2024},
  url = {https://github.com/[repo_url - replaced here]},
  license = {MIT}
}
```

## Contact

For bug reports, feature requests, or general inquiries, please contact us:

*   Email: [email protected]
*   GitHub Issues: [repo_url/issues - replaced here]
*  Community Discord Server [ link  here to Discord server - if exist ]